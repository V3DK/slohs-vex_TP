#pragma config(Sensor, in1,    gyro,           sensorGyro)
#pragma config(Sensor, in2,    power,          sensorAnalog)
#pragma config(Sensor, dgtl1,  rightDrive,     sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  leftDrive,      sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  liftE,          sensorQuadEncoder)
#pragma config(Motor,  port1,           frontLeft,     tmotorVex393HighSpeed_HBridge, openLoop, reversed)
#pragma config(Motor,  port2,           backLeft,      tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           fourbar,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           liftLeft,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           puncher,       tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           roller,        tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port7,           liftRight,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           wrist,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           backRight,     tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port10,          frontRight,    tmotorVex393HighSpeed_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*        Description: Competition template for VEX EDR                      */
/*                                                                           */
/*---------------------------------------------------------------------------*/

// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"


const short leftButton = 1;
const short centerButton = 2;
const short rightButton = 4;
string mainBattery, backupBattery;

//Variables for Toggle on Controllers



bool wristPressed = false;
bool wristStatus = false;
bool fourBarBool = false;
//deafult false cause flip out mech starts it there
//wristStatus is false when wrist is on the left position; it is able to turn the cap right, or clockwise
//wristStatus is true when wrist is on right position; it is able to turn the cap left, or counter-clockwise
//direction of clockwise/counter is taken from perspective of wrist motor

//Other Variables
bool autoPos = false;
int autonNum = 10;

/*---------------------------------------------------------------------------*/
/*                          Pre-Autonomous Functions                         */
/*                                                                           */
/*  You may want to perform some actions before the competition starts.      */
/*  Do them in the following function.  You must return from this function   */
/*  or the autonomous and usercontrol tasks will not be started.  This       */
/*  function is only called once after the cortex has been powered on and    */
/*  not every time that the robot is disabled.                               */
/*---------------------------------------------------------------------------*/


void clearDrive(){
	SensorValue[leftDrive] = 0;
	SensorValue[rightDrive] = 0;
}

void clearOthers(){
	SensorValue[liftE] = 0;
}

void clearAll(){
	clearDrive();
	clearOthers();
}

void waitForPress()
{
	while(nLCDButtons == 0){}
	wait1Msec(5);
}
void waitForRelease()
{
	while(nLCDButtons != 0){
		wait1Msec(5);

	}
}

void resetForAuton(){
	clearLCDLine(0);
	clearLCDLine(1);
	clearAll();
	bLCDBacklight = true;
	/* Gyro Setup */
	SensorType[gyro] = sensorNone;
	wait1Msec(50);
	SensorType[gyro] = sensorGyro;
	displayLCDCenteredString(0, "Calibrating");
	displayLCDCenteredString(1, "Gyro");
	//wait for it to calibrate
	wait1Msec(2000);
	SensorFullCount[gyro] = 3000;
	clearLCDLine(0);
	clearLCDLine(1);
}


void pre_auton()
{
	clearAll();
	// Set bStopTasksBetweenModes to false if you want to keep user created tasks
	// running between Autonomous and Driver controlled modes. You will need to
	// manage all user created tasks if set to false.
	bStopTasksBetweenModes = true;
	bDisplayCompetitionStatusOnLcd = false;

	resetForAuton();
	clearTimer(T1);
	//default
	autonNum = 2;
	//default
	while(time1[T1] < 1000) {
		displayLCDNumber(1, 0, time1[T1], 5);
		if(nLCDButtons == centerButton) {
			autoPos = true;
			displayLCDCenteredString(0, "Clicked");
		}
		wait1Msec( 15 );
	}
	if(autoPos){
		while(nLCDButtons != centerButton){
			switch(autonNum){
			case 0:
				displayLCDCenteredString(0, "redParking");
				displayLCDCenteredString(1, "<     Enter    >");
				waitForPress();
				if(nLCDButtons == leftButton){
					waitForRelease();
					autonNum = 7;
				}
				else if(nLCDButtons == rightButton){
					waitForRelease();
					autonNum++;
				}
				break;
			case 1:
				displayLCDCenteredString(0, "blueParking");
				displayLCDCenteredString(1, "<     Enter    >");
				waitForPress();
				if(nLCDButtons == leftButton){
					waitForRelease();
					autonNum--;
				}
				else if(nLCDButtons == rightButton){
					waitForRelease();
					autonNum++;
				}
				break;
			case 2:
				displayLCDCenteredString(0, "backRedFlag");
				displayLCDCenteredString(1, "<     Enter    >");
				waitForPress();
				if(nLCDButtons == leftButton){
					waitForRelease();
					autonNum--;
				}
				else if(nLCDButtons == rightButton){
					waitForRelease();
					autonNum++;
				}
				break;
			case 3:
				displayLCDCenteredString(0, "backBlueFlag");
				displayLCDCenteredString(1, "<     Enter    >");
				waitForPress();
				if(nLCDButtons == leftButton){
					waitForRelease();
					autonNum--;
				}
				else if(nLCDButtons == rightButton){
					waitForRelease();
					autonNum++;
				}
				break;
			case 4:
				displayLCDCenteredString(0, "3FlagRed");
				displayLCDCenteredString(1, "<     Enter    >");
				waitForPress();
				if(nLCDButtons == leftButton){
					waitForRelease();
					autonNum--;
				}
				else if(nLCDButtons == rightButton){
					waitForRelease();
					autonNum++;
				}
				break;
			case 5:
				displayLCDCenteredString(0, "3FlagBlue");
				displayLCDCenteredString(1, "<     Enter    >");
				waitForPress();
				if(nLCDButtons == leftButton){
					waitForRelease();
					autonNum--;
				}
				else if(nLCDButtons == rightButton){
					waitForRelease();
					autonNum++;
				}
				break;
			case 6:
				displayLCDCenteredString(0, "3FlagRpark");
				displayLCDCenteredString(1, "<     Enter    >");
				waitForPress();
				if(nLCDButtons == leftButton){
					waitForRelease();
					autonNum--;
				}
				else if(nLCDButtons == rightButton){
					waitForRelease();
					autonNum++;
				}
				break;
			case 7:
				displayLCDCenteredString(0, "3FlagBpark");
				displayLCDCenteredString(1, "<     Enter    >");
				waitForPress();
				if(nLCDButtons == leftButton){
					waitForRelease();
					autonNum--;
				}
				else if(nLCDButtons == rightButton){
					waitForRelease();
					autonNum = 0;
				}
				break;


			default:
				break;
			}	//switch

			wait1Msec(15);
		}	//while loop
	}	//if

	displayLCDCenteredString(0,"Auton Selected");
	clearLCDLine(1);

}

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              Autonomous Task                              */
/*                                                                           */
/*  This task is used to control your robot during the autonomous phase of   */
/*  a VEX Competition.                                                       */
/*                                                                           */
/*  You must modify the code to add your own robot specific commands here.   */
/*---------------------------------------------------------------------------*/

int avgDrive(){
	return (SensorValue[leftDrive] + SensorValue[rightDrive]) / 2.0;
}

void stopDrive(){
	motor[backLeft] = 0;
	motor[frontLeft] = 0;

	motor[backRight] = 0;

	motor[frontRight] = 0;
}


void driveFwd(int left, int right, int count){
	motor[backLeft] = left;

	motor[frontLeft] = left;
	motor[backRight] = right;

	motor[frontRight] = right;

	if((-1 * count) > 0){
		while(avgDrive() < (-1 * count)){

		}
		stopDrive();
	}
	else {
		while(avgDrive() > (-1 * count)){

		}
		stopDrive();
	}
	stopDrive();
	clearDrive();

}

//use with gyro n stuff
void driveMove(int left, int right){
	motor[backLeft] = (-1 * left);
	motor[frontLeft] = (-1 * left);
	motor[backRight] = (-1 * right);
	motor[frontRight] = (-1 * right);
}


void redParking(){
	motor[liftRight] = -15;
	motor[liftLeft] = -15;

	clearAll();
	driveFwd(80, 80, 315);
	wait1Msec(200);
	driveMove(80, -80);
	while(SensorValue[gyro] > -600){
	}
	stopDrive();

	driveFwd(112, 112, 1600);
	motor[liftRight] = -0;
	motor[liftLeft] = -0;
	wait1Msec(15000);
}
void blueParking(){
	motor[liftRight] = -15;
	motor[liftLeft] = -15;

	clearAll();
	driveFwd(80, 80, 315);
	wait1Msec(200);
	driveMove(-80, 80);
	while(SensorValue[gyro] < 620){
	}
	stopDrive();

	driveFwd(112, 112, 1550);
	motor[liftRight] = -0;
	motor[liftLeft] = -0;
	wait1Msec(15000);
}

void backRedFlag(){
	clearAll();
	wait1Msec(5000);
	motor[puncher] = 127;
	wait1Msec(2000);
	motor[puncher] = 0;
	clearAll();
	driveMove(70, 0);
	while(SensorValue[gyro] > -300){
	}
	stopDrive();
	wait1Msec(200);
	motor[roller] = -127;
	driveFwd(50, 50, 920);
	wait1Msec(700);
	clearDrive();
	driveFwd(-50, -50, -30);
	wait1Msec(200);
	clearAll();
	driveMove(-60, 60);
	while(SensorValue[gyro] < 300){
	}
	stopDrive();
	clearDrive();
	motor[liftRight] = -15;
	motor[liftLeft] = -15;
	driveFwd(120, 120, 650);
	motor[liftRight] = 0;
	motor[liftLeft] = 0;
	wait1Msec(10000);
}

void backBlueFlag(){
	clearAll();
	wait1Msec(5000);
	motor[puncher] = 127;
	wait1Msec(2000);
	motor[puncher] = 0;
	clearAll();
	driveMove(0, 70);
	while(SensorValue[gyro] < 300){
	}
	stopDrive();
	wait1Msec(200);
	motor[roller] = -127;
	driveFwd(50, 50, 920);
	wait1Msec(700);
	clearDrive();
	driveFwd(-50, -50, -30);
	wait1Msec(200);
	clearAll();
	driveMove(60, -60);
	while(SensorValue[gyro] > -300){
	}
	stopDrive();
	clearDrive();
	motor[liftRight] = -15;
	motor[liftLeft] = -15;
	driveFwd(120, 120, 650);
	motor[liftRight] = 0;
	motor[liftLeft] = 0;
	wait1Msec(10000);
}



void flag3Red(){
	motor[roller] = -127;
	clearAll();
	driveFwd(65, 65, 860);
	wait1Msec(700);
	clearAll();
	driveFwd(-100, -100, -425);
	motor[roller] = 0;
	driveFwd(-100, -100, -325);
	wait1Msec(200);
	driveMove(-50, 50);
	motor[puncher] = 127;
	while(SensorValue[gyro] < 770){

	}
	stopDrive();
	wait1Msec(100);
	clearAll();
	driveFwd(-50, -50, -80);
	clearAll();
	wait1Msec(500);
	motor[puncher] = 0;

	//second ball
	motor[roller] = -127;
	motor[puncher] = 127;
	clearAll();
	driveFwd(50, 50, 470);
	clearAll();

	wait1Msec(1500);
	motor[puncher] = 0;

	motor[roller] = 0;
	clearAll();
	driveFwd(50, 50, 300);
	clearAll();

	//left turn to hit flag
	driveMove(-60, 60);
	while(SensorValue[gyro] < 975){
	}
	stopDrive();
	wait1Msec(200);
	clearDrive();
	driveFwd(127, 127, 175);
	wait1Msec(200);
	clearAll();
	//driving back
	driveFwd(-127, -127, -175);
	clearAll();
	wait1Msec(10000);

}

void flag3Blue(){
	motor[roller] = -127;
	clearAll();
	driveFwd(60, 60, 860);
	wait1Msec(700);
	clearAll();
	driveFwd(-100, -100, -350);
	motor[roller] = 0;
	driveFwd(-100, -100, -380);
	wait1Msec(200);
	driveMove(50, -50);
	motor[puncher] = 90;
	while(SensorValue[gyro] > -730){
		//	if(SensorValue[gyro] < -100){
		//		motor[puncher] = 127;
		//		}
	}
	stopDrive();
	wait1Msec(100);
	clearAll();
	driveFwd(-50, -50, -80);
	clearAll();
	wait1Msec(500);
	motor[puncher] = 0;

	//second ball
	motor[roller] = -127;
	motor[puncher] = 127;
	clearAll();
	driveFwd(50, 50, 470);
	clearAll();

	wait1Msec(1500);
	motor[puncher] = 0;

	motor[roller] = 0;
	clearAll();
	driveFwd(50, 50, 270);
	clearAll();

	//left turn to hit flag
	driveMove(90, -90);
	while(SensorValue[gyro] > -1030){
	}
	stopDrive();
	wait1Msec(200);
	clearDrive();
	driveFwd(80, 80, 205);
	wait1Msec(200);
	clearAll();
	//driving back
	driveFwd(-60, -127, -175);
	clearAll();
	wait1Msec(10000);
}



void flag3RedPark(){
	motor[roller] = -127;
	clearAll();
	driveFwd(65, 65, 860);
	wait1Msec(700);
	clearAll();
	driveFwd(-100, -100, -425);
	motor[roller] = 0;
	driveFwd(-100, -100, -325);
	wait1Msec(200);
	driveMove(-50, 50);
	motor[puncher] = 127;
	while(SensorValue[gyro] < 770){

	}
	stopDrive();
	wait1Msec(100);
	clearAll();
	driveFwd(-50, -50, -80);
	clearAll();
	wait1Msec(500);
	motor[puncher] = 0;

	//second ball
	motor[roller] = -127;
	motor[puncher] = 127;
	clearAll();
	driveFwd(50, 50, 470);
	clearAll();

	wait1Msec(1500);
	motor[puncher] = 0;

	motor[roller] = 0;
	clearAll();
	driveFwd(50, 50, 300);
	clearAll();

	//left turn to hit flag
	driveMove(-60, 60);
	while(SensorValue[gyro] < 975){
	}
	stopDrive();
	wait1Msec(200);
	clearDrive();
	driveFwd(127, 127, 175);
	wait1Msec(200);
	clearAll();
	//driving back
	driveFwd(-127, -127, -175);
	clearAll();
	/*
	driveMove(60, -60);
	while(SensorValue[gyro] > 800){
	}
	stopDrive();
	*/
	clearAll();
	driveFwd(-120, -120, -1500);
	clearAll();
	driveMove(50, -50);
	motor[liftRight] = -15;
	motor[liftLeft] = -15;
	while(SensorValue[gyro] > 200){
	}
	stopDrive();
	driveFwd(127, 127, 1200);
	motor[liftRight] = 0;
	motor[liftLeft] = 0;
	wait1Msec(10000);

}

void flag3BluePark(){
	motor[roller] = -127;
	clearAll();
	driveFwd(60, 60, 860);
	wait1Msec(700);
	clearAll();
	driveFwd(-100, -100, -350);
	motor[roller] = 0;
	driveFwd(-100, -100, -380);
	wait1Msec(200);
	driveMove(50, -50);
	motor[puncher] = 90;
	while(SensorValue[gyro] > -730){
		//	if(SensorValue[gyro] < -100){
		//		motor[puncher] = 127;
		//		}
	}
	stopDrive();
	wait1Msec(100);
	clearAll();
	driveFwd(-50, -50, -80);
	clearAll();
	wait1Msec(500);
	motor[puncher] = 0;

	//second ball
	motor[roller] = -127;
	motor[puncher] = 127;
	clearAll();
	driveFwd(50, 50, 470);
	clearAll();

	wait1Msec(1500);
	motor[puncher] = 0;

	motor[roller] = 0;
	clearAll();
	driveFwd(50, 50, 270);
	clearAll();

	//left turn to hit flag
	driveMove(90, -90);
	while(SensorValue[gyro] > -1030){
	}
	stopDrive();
	wait1Msec(200);
	clearDrive();
	driveFwd(80, 80, 205);
	wait1Msec(200);
	clearAll();
	//driving back
	driveFwd(-60, -127, -175);
	clearAll();
	/*
	driveMove(60, -60);
	while(SensorValue[gyro] > 800){
	}
	stopDrive();
	*/
	clearAll();
	driveFwd(-60, -125, -1600);
	clearAll();
	driveMove(-50, 50);
	motor[liftRight] = -15;
	motor[liftLeft] = -15;
	while(SensorValue[gyro] < -200){
	}
	stopDrive();
	driveFwd(127, 127, 1200);
	motor[liftRight] = 0;
	motor[liftLeft] = 0;
	wait1Msec(10000);
}



task autonomous()
{
	//LCD STUFF code
	//clear timer for auton while's
	clearTimer(T2);
	clearLCDLine(0);
	clearLCDLine(1);
	switch (autonNum){
	case 0:
		displayLCDCenteredString(0, "redParking");
		redParking();
	case 1:
		displayLCDCenteredString(0, "blueParking");
		blueParking();
	case 2:
		displayLCDCenteredString(0, "backRedFlag");
		backRedFlag();
	case 3:
		displayLCDCenteredString(0, "backBlueFlag");
		backBlueFlag();
	case 4:
		displayLCDCenteredString(0, "3FlagRed");
		flag3Red();
	case 5:
		displayLCDCenteredString(0, "3FlagBlue");
		flag3Blue();
	case 6:
		displayLCDCenteredString(0, "3FlagRed&Park");
		flag3RedPark();
	case 7:
		displayLCDCenteredString(0, "3FlagBlue&Park");
		flag3BluePark();
	default:
		displayLCDCenteredString(0, "No Auton Selected!");
		break;
	}
}

void wristToggleMovement(bool e){
	int wristToggleTime = 420;
	int margin = 0.2 * wristToggleTime;
	int temp = 0;
	if(!e)
		temp = 1;
	else
		temp = -1;
	//if e is false, need to turn right
	//if e is true, need to turn left
	clearTimer(T2);
	int motorVal = 60 * temp;
	motor[wrist] = motorVal;
	while(time1[T2] < wristToggleTime){
		if(time1[T2] > (wristToggleTime - margin)){
			//start slowing motor power so it doesn't hit with big momentum
			if((wristToggleTime - time1[T2]) < (margin / 4)){
				motor[wrist] = 10 * temp;
			}
			else if((wristToggleTime - time1[T2]) < (margin / 2)){
				motor[wrist] = motorVal / 2; //half of start value
			}
		}
	}
	motor[wrist] = 7 * temp;

	//end stuff to reset and updating stuff
	wristPressed = false;

	//now that the wrist has moved, we can update it's position by inversing the boolean
	wristStatus = !wristStatus;
}

void driveTrain(){
	motor[frontLeft] = vexRT[Ch2];
	motor[backLeft] = vexRT[Ch2];

	motor[frontRight] = vexRT[Ch3];
	motor[backRight] = vexRT[Ch3];
}

void straightDrive(){
	//up button drives perfectly forward
	//down button drives perfectly backward
	//when nothing is pressed, drive is still, so no annoying motor humming (:

	if(vexRT[Btn7U] == 1) {
		motor[backLeft] = 90;
		motor[frontLeft] = 90;
		motor[backRight] = 90;
		motor[frontRight] = 90;		
		} else if(vexRT[Btn7D] == 1) {
		motor[backLeft] = -90;
		motor[frontLeft] = -90;
		motor[backRight] = -90;
		motor[frontRight] = -90;
		} else {
		motor[backLeft] = 0;
		motor[frontLeft] = 0;
		motor[backRight] = 0;
		motor[frontRight] = 0;	
	}

}

void rollerMove(){
	if(vexRT[Btn5U] == 1) {
		motor[roller] = 127;
		} else if(vexRT[Btn5D] == 1) {
		motor[roller] = -127;
		} else {
		motor[roller] = 0;
	}
}
void slowFourBar(){
	//only works when fourbar is holding cap, so we can slowly lower it
	if(fourBarBool){
		if(vexRT[Btn7UXmtr2] == 1) {
			motor[fourbar] = -10;
			} else if(vexRT[Btn7DXmtr2] == 1) {
			motor[fourbar] = 25;
			} else {
			motor[fourbar] = 15;
		}

	}
}

void fourBarMove(){
	if(vexRT[Btn5UXmtr2] == 1) {
		//down
		motor[fourbar] = -127;
		fourBarBool = false;
		} else if(vexRT[Btn5DXmtr2] == 1) {
		motor[fourbar] = 127;
		fourBarBool = true;
		} else {

		if(fourBarBool){
			motor[fourbar] = 15;
		}
		else if(!fourBarBool){
			motor[fourbar] = -10;
		}
		else{
			motor[fourbar] = 0;
		}
	}
}


void mainLift(){
	if(vexRT[Btn6DXmtr2] == 1) {
		motor[liftRight] = 127;
		motor[liftLeft] = 127;
		} else if(vexRT[Btn6UXmtr2] == 1) {
		motor[liftRight] = -127;
		motor[liftLeft] = -127;
		} else {
		motor[liftRight] = 0;
		motor[liftLeft] = 0;
	}
}
void puncherMove(){
	if(vexRT[Btn6U] == 1) {
		motor[puncher] = -127;
		} else if(vexRT[Btn6D] == 1) {
		motor[puncher] = 127;
		} else {
		motor[puncher] = 0;
	}
}


void wristToggleCheck(){
	// check for a button press only if we are not already pressed.
	if(vexRT[Btn8RXmtr2] == 1)
	{
		if(!wristPressed){
			waitUntil(vexRT[Btn8RXmtr2] == 0);
			wristPressed = true;
		}
	}

}

void resetAuton(){
	if(nLCDButtons == centerButton){
		waitForRelease();
		resetForAuton();
	}
}

void regularRemote(){
	//regular button pressing

	//veds
	driveTrain();
	puncherMove();
	rollerMove();
	//	straightDrive();


	//tanvis
	mainLift();
	slowFourBar();
	fourBarMove();


	//toggles and special stuff
	wristToggleCheck();

	//LCD and other display stuff
	//reset values for trying auton
	resetAuton();
}


task wristM(){
	while(true){
		if(wristPressed){
			//code to run for moving wrist
			wristToggleMovement(wristStatus);
			//run wrist function goes here^
		}
		wait1Msec(20);
	}
}


void displayBattery(){
	//Display the Primary Robot battery voltage
	//displayLCDString(0, 0, "Primary: ");
	sprintf(mainBattery, "%1.2f%c", nImmediateBatteryLevel/974.0,'V'); //Build the value to be displayed
	displayNextLCDString(mainBattery);

	//Display the Backup battery voltage
	//displayLCDString(1, 0, "Backup: ");
	sprintf(backupBattery, "%1.2f%c", BackupBatteryLevel/1000.0, 'V');    //Build the value to be displayed
	displayNextLCDString(backupBattery);
	
	wait1Msec(1000);
}

void displaySensor(){
	displayLCDString(0, 0, "G ");
	displayLCDNumber(0, 2, SensorValue[gyro]);
	displayLCDString(0, 7, "RD ");
	displayLCDNumber(0, 10, SensorValue[rightDrive]);
	displayLCDString(1, 0, "LD ");
	displayLCDNumber(1, 3, SensorValue[leftDrive]);
	displayLCDString(1, 7, "L ");
	displayLCDNumber(1, 9, SensorValue[liftE]);
}

task usercontrol()
{
	//wristToggle Task
	startTask(wristM);



	clearAll();
	while (true) {
		//Main Controls for Everything
		regularRemote();
		clearLCDLine(0);
		clearLCDLine(1);

		if(false){
			displaySensor();
		}
		else if (true){
			displayBattery();
		}
		else if (true){
			displayLCDCenteredString(0, "User");
			displayLCDCenteredString(1, "Control");
		}
		wait1Msec(10);
	}
	stopTask(wristM);
}