#pragma config(Sensor, in1,    gyro,           sensorGyro)
#pragma config(Sensor, dgtl1,  rightDrive,     sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  leftDrive,      sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  liftE,          sensorQuadEncoder)
#pragma config(Motor,  port1,           backRight,     tmotorVex393HighSpeed_HBridge, openLoop, reversed)
#pragma config(Motor,  port2,           middleRight,   tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           frontRight,    tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           lift,          tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port5,           puncher,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           roller,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           wrist,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           frontLeft,     tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port9,           middleLeft,    tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port10,          backLeft,      tmotorVex393HighSpeed_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*        Description: Competition template for VEX EDR                      */
/*                                                                           */
/*---------------------------------------------------------------------------*/

// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"


//Variables for Toggle on Controllers
int wristToggleState = 0;
int wristButtonPressed = 0;
bool wristStatus = false;
//deafult false cause flip out mech starts it there
//wristStatus is false when wrist is on the left position; it is able to turn the cap right, or clockwise
//wristStatus is true when wrist is on right position; it is able to turn the cap left, or counter-clockwise
//direction of clockwise/counter is taken from perspective of wrist motor

int rollerToggleState = 0;
int rollerButtonPressed = 0;
bool rollerOn = false;

//Other Variables
bool autoPos = false;
int autonNum = 10;


/*
void wristToggleMovement(bool e){
	int wristToggleTime = 500;
//if e is false, need to turn right
//if e is true, need to turn left
	if(!e){
		motor[wrist] = 30;
		wait1Msec(wristToggleTime);
		motor[wrist] = 0;
	}
	else {
		motor[wrist] = -30;
		wait1Msec(wristToggleTime);
		motor[wrist] = 0;

	}

	//now that the wrist has moved, we can update it's position by inversing the boolean
	wristStatus = !wristStatus;


}

task wristToggleTask(){
//toggle the wrist
	while(true){
		if(wristToggleState == 1){
            //code to run for moving wrist
            //passes true or false based on position or wrist - corresponds to wristToggleMovement method of moving
            //wristToggleMovement(wristStatus);
            motor[wrist] = 10;
			wait1Msec(200);
			motor[wrist] = 0;
		}
        wait1Msec(15);
	}
}

task rollerToggleTask(){
	/*while(true){
		if(!rollerOn){
			motor[roller] = 127;
		}
		else if(rollerOn){
			motor[roller] = 0;
		}

		wait1Msec(15);
	}
	

}
*/
/*---------------------------------------------------------------------------*/
/*                          Pre-Autonomous Functions                         */
/*                                                                           */
/*  You may want to perform some actions before the competition starts.      */
/*  Do them in the following function.  You must return from this function   */
/*  or the autonomous and usercontrol tasks will not be started.  This       */
/*  function is only called once after the cortex has been powered on and    */
/*  not every time that the robot is disabled.                               */
/*---------------------------------------------------------------------------*/


void clearDrive(){
	SensorValue[leftDrive] = 0;
	SensorValue[rightDrive] = 0;
}

void clearOthers(){
	SensorValue[liftE] = 0;
}

void clearAll(){
	clearDrive();
	clearOthers();
}

void waitForPress()
{
	while(nLCDButtons == 0){}
	wait1Msec(5);
}
void waitForRelease()
{
	while(nLCDButtons != 0){
		wait1Msec(5);
	
	}
}
	

void pre_auton()
{
	clearAll();
  // Set bStopTasksBetweenModes to false if you want to keep user created tasks
  // running between Autonomous and Driver controlled modes. You will need to
  // manage all user created tasks if set to false.
  bStopTasksBetweenModes = true;
  bDisplayCompetitionStatusOnLcd = false;

  	const short leftButton = 1;
	const short centerButton = 2;
	const short rightButton = 4;
	clearLCDLine(0);
	clearLCDLine(1);
	bLCDBacklight = true;
	/* Gyro Setup */
	SensorType[gyro] = sensorNone;
	wait1Msec(50);
	SensorType[gyro] = sensorGyro;
	displayLCDCenteredString(0, "Calibrating");
	displayLCDCenteredString(1, "Gyro");
	//wait for it to calibrate
	wait1Msec(2000);
	SensorFullCount[gyro] = 3000;
	clearLCDLine(0);
	clearLCDLine(1);
	clearTimer(T1);
	autonNum = 2;
	while(time1[T1] < 1000) {
		displayLCDNumber(1, 0, time1[T1], 5);
		if(nLCDButtons == centerButton) {
			autoPos = true;
			displayLCDCenteredString(0, "Clicked");
		}
		 wait1Msec( 15 );
	}
	if(autoPos){
		while(nLCDButtons != centerButton){
			switch(autonNum){
			case 0:
				displayLCDCenteredString(0, "Right Parking");
				displayLCDCenteredString(1, "<     Enter    >");
				waitForPress();
				if(nLCDButtons == leftButton){
					waitForRelease();
					autonNum = 5;
				}
				else if(nLCDButtons == rightButton){
					waitForRelease();
					autonNum++;
				}
				break;
			case 1:
				displayLCDCenteredString(0, "Left Parking");
				displayLCDCenteredString(1, "<     Enter    >");
				waitForPress();
				if(nLCDButtons == leftButton){
					waitForRelease();
					autonNum--;
				}
				else if(nLCDButtons == rightButton){
					waitForRelease();
					autonNum++;
				}
				break;
			case 2:
				displayLCDCenteredString(0, "redFlagPark");
				displayLCDCenteredString(1, "<     Enter    >");
				waitForPress();
				if(nLCDButtons == leftButton){
					waitForRelease();
					autonNum--;
				}
				else if(nLCDButtons == rightButton){
					waitForRelease();
					autonNum++;
				}
				break;
			case 3:
				displayLCDCenteredString(0, "blueFlagPark");
				displayLCDCenteredString(1, "<     Enter    >");
				waitForPress();
				if(nLCDButtons == leftButton){
					waitForRelease();
					autonNum--;
				}
				else if(nLCDButtons == rightButton){
					waitForRelease();
					autonNum++;
				}
				break;
			case 4:
				displayLCDCenteredString(0, "Some Auton");
				displayLCDCenteredString(1, "<     Enter    >");
				waitForPress();
				if(nLCDButtons == leftButton){
					waitForRelease();
					autonNum--;
				}
				else if(nLCDButtons == rightButton){
					waitForRelease();
					autonNum++;
				}
				break;
			case 5:
				displayLCDCenteredString(0, "Some Auton");
				displayLCDCenteredString(1, "<     Enter    >");
				waitForPress();
				if(nLCDButtons == leftButton){
					waitForRelease();
					autonNum--;
				}
				else if(nLCDButtons == rightButton){
					waitForRelease();
					autonNum = 0;
				}
				break;
			default:
				break;
			}	//switch

			 wait1Msec(15);
		}	//while loop
	}	//if

	displayLCDCenteredString(0,"Auton Selected");
	clearLCDLine(1);

}

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              Autonomous Task                              */
/*                                                                           */
/*  This task is used to control your robot during the autonomous phase of   */
/*  a VEX Competition.                                                       */
/*                                                                           */
/*  You must modify the code to add your own robot specific commands here.   */
/*---------------------------------------------------------------------------*/

int avgDrive(){
return (SensorValue[leftDrive] + SensorValue[rightDrive]) / 2.0;	
}

void stopDrive(){
	motor[backLeft] = 0;
	motor[middleLeft] = 0;
	motor[frontLeft] = 0;
	
		motor[backRight] = 0;
	motor[middleRight] = 0;
	motor[frontRight] = 0;
}


void driveFwd(int left, int right, int count){
	motor[backLeft] = left;
	motor[middleLeft] = left;
	motor[frontLeft] = left;
		motor[backRight] = right;
	motor[middleRight] = right;
	motor[frontRight] = right;
	
	if(count>0){
	while(avgDrive() < count){
		
		}
	stopDrive();
}
	else {
		while(avgDrive() > count){
			
		}
	stopDrive();
	}
	stopDrive();
	clearDrive();
	
}

//use with gyro n stuff
void driveMove(int left, int right){
	motor[backLeft] = left;
	motor[middleLeft] = left;
	motor[frontLeft] = left;
		motor[backRight] = right;
	motor[middleRight] = right;
	motor[frontRight] = right;
}


void rightParking(){
	clearAll();
	driveFwd(-80, -80, -330);
	wait1Msec(200);
	driveMove(80, -80);
	while(SensorValue[gyro] > -750){	
	}
	stopDrive();
	
	driveFwd(-127, -127, -1400);
	wait1Msec(15000);
}
void leftParking(){
	clearAll();
	driveFwd(-80, -80, -330);
	wait1Msec(200);
	driveMove(-80, 80);
	while(SensorValue[gyro] < 750){	
	}
	stopDrive();
	
	driveFwd(-127, -127, -1400);
	wait1Msec(15000);
}

void redFlagParking(){
	clearAll();
	driveFwd(-80, -80, -1000);
	wait1Msec(800);
	driveFwd(80, 80, 1480);
	wait1Msec(300);
	driveMove(80, -80);
	while(SensorValue[gyro] > -600){	
	}
	stopDrive();
	wait1Msec(300);
	driveFwd(-127, -127, -1400);
	wait1Msec(15000);
}

void blueFlagParking(){
	clearAll();
	driveFwd(-80, -80, -1000);
	wait1Msec(800);
	driveFwd(80, 80, 1480);
	wait1Msec(300);
	driveMove(-80, 80);
	while(SensorValue[gyro] < 600){	
	}
	stopDrive();
	wait1Msec(300);
	driveFwd(-127, -127, -1400);
	wait1Msec(15000);
}


task autonomous()
{
  //LCD STUFF code
	//clear timer for auton while's
	clearTimer(T2);
	clearLCDLine(0);
	clearLCDLine(1);
	switch (autonNum){
	case 0:
		displayLCDCenteredString(0, "RightParking");
		rightParking();
		//default for NOW
		//redFlagParking();
	case 1:
		displayLCDCenteredString(0, "LeftParking");
		leftParking();
	case 2:
		displayLCDCenteredString(0, "RedFlagParking");
	//	point10RGyro(true);
		redFlagParking();
	case 3:
		displayLCDCenteredString(0, "BlueFlagParking");
	//	point10LGyro(true);
		blueFlagParking();
	case 4:
		displayLCDCenteredString(0, "Other");
	//	point5RGyro(true);
	case 5:
		displayLCDCenteredString(0, "Other");
	//	point5LGyro(true);
	default:
		displayLCDCenteredString(0, "No Auton Selected!");
		break;
		
	}

}


void driveTrain(){
	motor[frontLeft] = vexRT[Ch3];
	motor[middleLeft] = vexRT[Ch3];
	motor[backLeft] = vexRT[Ch3];
	
	motor[frontRight] = vexRT[Ch2];
	motor[middleRight] = vexRT[Ch2];
	motor[backRight] = vexRT[Ch2];
}
void rollerMove(){
	if(vexRT[Btn6U] == 1) {
		motor[roller] = 127;
		} else if(vexRT[Btn6D] == 1) {
		motor[roller] = -127;
		} else {
		motor[roller] = 0;
	}
}
void wristMove(){
	if(vexRT[Btn8UXmtr2] == 1) {
		motor[wrist] = -40;
		} else if(vexRT[Btn8DXmtr2] == 1) {
		motor[wrist] = 40;
		} else {
		motor[wrist] = 0;
	}
}
void mainLift(){
	if(vexRT[Btn6DXmtr2] == 1) {
		motor[lift] = 127;
		} else if(vexRT[Btn6UXmtr2] == 1) {
		motor[lift] = -100;
		} else {
		motor[lift] = 0;
	}
}
void puncherMove(){
	if(vexRT[Btn7UXmtr2] == 1) {
		motor[puncher] = 127;
		} else if(vexRT[Btn7DXmtr2] == 1) {
		motor[puncher] = -127;
		} else {
		motor[puncher] = 0;
	}
}

/*
void wristToggleCheck(){
	while(true) {
        // check for a button press only if we are not already pressed.
        if( vexRT[ Btn8RXmtr2 ] == 1 )
            {
            if(!wristButtonPressed)
              {
              // change the toggle state
              wristToggleState = 1 - wristToggleState;

              // Note the button is pressed
              wristButtonPressed = 1;

              }
            }
        else
            {
            // the button is not pressed
            wristButtonPressed = 0;
            }



        wait1Msec(15);
}
}

void rollerToggleCheck(){
	while(true) {
        // check for a button press only if we are not already pressed.
        if( vexRT[Btn5U] == 1 )
            {
            if(!rollerButtonPressed)
              {
              // change the toggle state
              rollerToggleState = 1 - rollerToggleState;
              // Note the button is pressed
              rollerButtonPressed = 1;

              }
            }
        else
            {
            // the button is not pressed
            rollerButtonPressed = 0;
            }
        wait1Msec(15);
}
	
}
*/



void regularRemote(){
	//regular button pressing
	driveTrain();
	mainLift();
	puncherMove();

	rollerMove();
	wristMove();
	//toggles and special stuff
////	wristToggleCheck();
//	rollerToggleCheck();

}




task usercontrol()
{
	//wristToggle Tastk
	//startTask(wristToggleTask);
	//startTask(rollerToggleTask);
 
  while (true)
  {
clearAll();
	while (true) {
		//Main Controls for Everything
		regularRemote();
		clearLCDLine(0);
		clearLCDLine(1);

		if(true){

			displayLCDString(0, 0, "G ");
			displayLCDNumber(0, 2, SensorValue[gyro]);
			
			displayLCDString(0, 7, "RD ");
			displayLCDNumber(0, 10, SensorValue[rightDrive]);

			displayLCDString(1, 0, "LD ");
			displayLCDNumber(1, 3, SensorValue[leftDrive]);
			
			
			displayLCDString(1, 7, "L ");
			displayLCDNumber(1, 9, SensorValue[lift]);
		}
		else {
			displayLCDCenteredString(0, "User");
			displayLCDCenteredString(1, "Control");

		}
  }

   wait1Msec(25);
   
 }
 
}