#pragma config(Sensor, in1,    gyro,           sensorGyro)
#pragma config(Sensor, in2,    power,          sensorAnalog)
#pragma config(Sensor, dgtl1,  rightDrive,     sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  leftDrive,      sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  liftE,          sensorQuadEncoder)
#pragma config(Motor,  port1,           backRight,     tmotorVex393HighSpeed_HBridge, openLoop, reversed)
#pragma config(Motor,  port2,           middleRight,   tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           frontRight,    tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           lift,          tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port5,           puncher,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           roller,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           wrist,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           frontLeft,     tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port9,           middleLeft,    tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port10,          backLeft,      tmotorVex393HighSpeed_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*        Description: Competition template for VEX EDR                      */
/*                                                                           */
/*---------------------------------------------------------------------------*/

// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"


//Variables for Toggle on Controllers



bool wristPressed = false;
bool wristStatus = false;
//deafult false cause flip out mech starts it there
//wristStatus is false when wrist is on the left position; it is able to turn the cap right, or clockwise
//wristStatus is true when wrist is on right position; it is able to turn the cap left, or counter-clockwise
//direction of clockwise/counter is taken from perspective of wrist motor

//Other Variables
bool autoPos = false;
int autonNum = 10;


void wristToggleMovement(bool e){
	int wristToggleTime = 420;
	int margin = 0.2 * wristToggleTime;
	int temp = 0;
	if(!e)
		temp = 1;
	else
		temp = -1;
	//if e is false, need to turn right
	//if e is true, need to turn left
	clearTimer(T2);
	int motorVal = 60 * temp;
	motor[wrist] = motorVal;
	while(time1[T2] < wristToggleTime){
		if(time1[T2] > (wristToggleTime - margin)){
			//start slowing motor power so it doesn't hit with big momentum
			if((wristToggleTime - time1[T2]) < (margin / 4)){
				motor[wrist] = 10 * temp;
			}
			else if((wristToggleTime - time1[T2]) < (margin / 2)){
				motor[wrist] = motorVal / 2; //half of start value
			}
		}
	}
	motor[wrist] = 7 * temp;

	//end stuff to reset and updating stuff
	wristPressed = false;

	//now that the wrist has moved, we can update it's position by inversing the boolean
	wristStatus = !wristStatus;
}
/*
task wristToggleTask(){
	//toggle the wrist
	while(true){

		wait1Msec(15);
	}
}

*/
/*---------------------------------------------------------------------------*/
/*                          Pre-Autonomous Functions                         */
/*                                                                           */
/*  You may want to perform some actions before the competition starts.      */
/*  Do them in the following function.  You must return from this function   */
/*  or the autonomous and usercontrol tasks will not be started.  This       */
/*  function is only called once after the cortex has been powered on and    */
/*  not every time that the robot is disabled.                               */
/*---------------------------------------------------------------------------*/


void clearDrive(){
	SensorValue[leftDrive] = 0;
	SensorValue[rightDrive] = 0;
}

void clearOthers(){
	SensorValue[liftE] = 0;
}

void clearAll(){
	clearDrive();
	clearOthers();
}

void waitForPress()
{
	while(nLCDButtons == 0){}
	wait1Msec(5);
}
void waitForRelease()
{
	while(nLCDButtons != 0){
		wait1Msec(5);

	}
}


void pre_auton()
{
	clearAll();
	// Set bStopTasksBetweenModes to false if you want to keep user created tasks
	// running between Autonomous and Driver controlled modes. You will need to
	// manage all user created tasks if set to false.
	bStopTasksBetweenModes = true;
	bDisplayCompetitionStatusOnLcd = false;

	const short leftButton = 1;
	const short centerButton = 2;
	const short rightButton = 4;
	clearLCDLine(0);
	clearLCDLine(1);
	bLCDBacklight = true;
	/* Gyro Setup */
	SensorType[gyro] = sensorNone;
	wait1Msec(50);
	SensorType[gyro] = sensorGyro;
	displayLCDCenteredString(0, "Calibrating");
	displayLCDCenteredString(1, "Gyro");
	//wait for it to calibrate
	wait1Msec(2000);
	SensorFullCount[gyro] = 3000;
	clearLCDLine(0);
	clearLCDLine(1);
	clearTimer(T1);
	autonNum = 2;
	while(time1[T1] < 1000) {
		displayLCDNumber(1, 0, time1[T1], 5);
		if(nLCDButtons == centerButton) {
			autoPos = true;
			displayLCDCenteredString(0, "Clicked");
		}
		wait1Msec( 15 );
	}
	if(autoPos){
		while(nLCDButtons != centerButton){
			switch(autonNum){
			case 0:
				displayLCDCenteredString(0, "Right Parking");
				displayLCDCenteredString(1, "<     Enter    >");
				waitForPress();
				if(nLCDButtons == leftButton){
					waitForRelease();
					autonNum = 5;
				}
				else if(nLCDButtons == rightButton){
					waitForRelease();
					autonNum++;
				}
				break;
			case 1:
				displayLCDCenteredString(0, "Left Parking");
				displayLCDCenteredString(1, "<     Enter    >");
				waitForPress();
				if(nLCDButtons == leftButton){
					waitForRelease();
					autonNum--;
				}
				else if(nLCDButtons == rightButton){
					waitForRelease();
					autonNum++;
				}
				break;
			case 2:
				displayLCDCenteredString(0, "redFlagPark");
				displayLCDCenteredString(1, "<     Enter    >");
				waitForPress();
				if(nLCDButtons == leftButton){
					waitForRelease();
					autonNum--;
				}
				else if(nLCDButtons == rightButton){
					waitForRelease();
					autonNum++;
				}
				break;
			case 3:
				displayLCDCenteredString(0, "blueFlagPark");
				displayLCDCenteredString(1, "<     Enter    >");
				waitForPress();
				if(nLCDButtons == leftButton){
					waitForRelease();
					autonNum--;
				}
				else if(nLCDButtons == rightButton){
					waitForRelease();
					autonNum++;
				}
				break;
			case 4:
				displayLCDCenteredString(0, "Some Auton");
				displayLCDCenteredString(1, "<     Enter    >");
				waitForPress();
				if(nLCDButtons == leftButton){
					waitForRelease();
					autonNum--;
				}
				else if(nLCDButtons == rightButton){
					waitForRelease();
					autonNum++;
				}
				break;
			case 5:
				displayLCDCenteredString(0, "Some Auton");
				displayLCDCenteredString(1, "<     Enter    >");
				waitForPress();
				if(nLCDButtons == leftButton){
					waitForRelease();
					autonNum--;
				}
				else if(nLCDButtons == rightButton){
					waitForRelease();
					autonNum = 0;
				}
				break;
			default:
				break;
			}	//switch

			wait1Msec(15);
		}	//while loop
	}	//if

	displayLCDCenteredString(0,"Auton Selected");
	clearLCDLine(1);

}

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              Autonomous Task                              */
/*                                                                           */
/*  This task is used to control your robot during the autonomous phase of   */
/*  a VEX Competition.                                                       */
/*                                                                           */
/*  You must modify the code to add your own robot specific commands here.   */
/*---------------------------------------------------------------------------*/

int avgDrive(){
	return (SensorValue[leftDrive] + SensorValue[rightDrive]) / 2.0;
}

void stopDrive(){
	motor[backLeft] = 0;
	motor[middleLeft] = 0;
	motor[frontLeft] = 0;

	motor[backRight] = 0;
	motor[middleRight] = 0;
	motor[frontRight] = 0;
}


void driveFwd(int left, int right, int count){
	motor[backLeft] = left;
	motor[middleLeft] = left;
	motor[frontLeft] = left;
	motor[backRight] = right;
	motor[middleRight] = right;
	motor[frontRight] = right;

	if(count>0){
		while(avgDrive() < count){

		}
		stopDrive();
	}
	else {
		while(avgDrive() > count){

		}
		stopDrive();
	}
	stopDrive();
	clearDrive();

}

//use with gyro n stuff
void driveMove(int left, int right){
	motor[backLeft] = left;
	motor[middleLeft] = left;
	motor[frontLeft] = left;
	motor[backRight] = right;
	motor[middleRight] = right;
	motor[frontRight] = right;
}


void rightParking(){
	clearAll();
	driveFwd(-80, -80, -330);
	wait1Msec(200);
	driveMove(80, -80);
	while(SensorValue[gyro] > -750){	
	}
	stopDrive();

	driveFwd(-127, -127, -1400);
	wait1Msec(15000);
}
void leftParking(){
	clearAll();
	driveFwd(-80, -80, -330);
	wait1Msec(200);
	driveMove(-80, 80);
	while(SensorValue[gyro] < 750){	
	}
	stopDrive();

	driveFwd(-127, -127, -1400);
	wait1Msec(15000);
}

void redFlagParking(){
	clearAll();
	driveFwd(-80, -80, -1000);
	wait1Msec(800);
	driveFwd(80, 80, 1480);
	wait1Msec(300);
	driveMove(80, -80);
	while(SensorValue[gyro] > -600){	
	}
	stopDrive();
	wait1Msec(300);
	driveFwd(-127, -127, -1400);
	wait1Msec(15000);
}

void blueFlagParking(){
	clearAll();
	driveFwd(-80, -80, -1000);
	wait1Msec(800);
	driveFwd(80, 80, 1480);
	wait1Msec(300);
	driveMove(-80, 80);
	while(SensorValue[gyro] < 600){	
	}
	stopDrive();
	wait1Msec(300);
	driveFwd(-127, -127, -1400);
	wait1Msec(15000);
}


task autonomous()
{
	//LCD STUFF code
	//clear timer for auton while's
	clearTimer(T2);
	clearLCDLine(0);
	clearLCDLine(1);
	switch (autonNum){
	case 0:
		displayLCDCenteredString(0, "RightParking");
		rightParking();
		//default for NOW
		//redFlagParking();
	case 1:
		displayLCDCenteredString(0, "LeftParking");
		leftParking();
	case 2:
		displayLCDCenteredString(0, "RedFlagParking");
		//	point10RGyro(true);
		redFlagParking();
	case 3:
		displayLCDCenteredString(0, "BlueFlagParking");
		//	point10LGyro(true);
		blueFlagParking();
	case 4:
		displayLCDCenteredString(0, "Other");
		//	point5RGyro(true);
	case 5:
		displayLCDCenteredString(0, "Other");
		//	point5LGyro(true);
	default:
		displayLCDCenteredString(0, "No Auton Selected!");
		break;

	}

}


void driveTrain(){
	motor[frontLeft] = vexRT[Ch3];
	motor[middleLeft] = vexRT[Ch3];
	motor[backLeft] = vexRT[Ch3];

	motor[frontRight] = vexRT[Ch2];
	motor[middleRight] = vexRT[Ch2];
	motor[backRight] = vexRT[Ch2];
}
void rollerMove(){
	if(vexRT[Btn6U] == 1) {
		motor[roller] = 127;
		} else if(vexRT[Btn6D] == 1) {
		motor[roller] = -127;
		} else {
		motor[roller] = 0;
	}
}
void wristMove(){
	/*
	if(vexRT[Btn8UXmtr2] == 1) {
		motor[wrist] = -40;
		} else if(vexRT[Btn8DXmtr2] == 1) {
		motor[wrist] = 40;
		} else {
		motor[wrist] = 0;
	
	
		}	*/
}
void mainLift(){
	if(vexRT[Btn6DXmtr2] == 1) {
		motor[lift] = 127;
		} else if(vexRT[Btn6UXmtr2] == 1) {
		motor[lift] = -100;
		} else {
		motor[lift] = 0;
	}
}
void puncherMove(){
	if(vexRT[Btn7UXmtr2] == 1) {
		motor[puncher] = 127;
		} else if(vexRT[Btn7DXmtr2] == 1) {
		motor[puncher] = -127;
		} else {
		motor[puncher] = 0;
	}
}


void wristToggleCheck(){
		// check for a button press only if we are not already pressed.
		if(vexRT[Btn8RXmtr2] == 1)
		{
			if(!wristPressed){
				waitUntil(vexRT[Btn8RXmtr2] == 0);
				wristPressed = true;
			}
		}
		
}



void regularRemote(){
	//regular button pressing
	driveTrain();
	mainLift();
	puncherMove();

	rollerMove();
	wristMove();
	//toggles and special stuff
	wristToggleCheck();


}
task usercontrol()
{
	//wristToggle Tastk

	clearAll();
	string mainBattery;
	string expanderBattery;

	while (true) {
		//Main Controls for Everything
		regularRemote();
		clearLCDLine(0);
		clearLCDLine(1);
		
				if(wristPressed){
			//code to run for moving wrist
			wristToggleMovement(wristStatus);
			//run wrist function goes here^
		}

		if(true){

			displayLCDString(0, 0, "G ");
			displayLCDNumber(0, 2, SensorValue[gyro]);

			displayLCDString(0, 7, "RD ");
			displayLCDNumber(0, 10, SensorValue[rightDrive]);

			displayLCDString(1, 0, "LD ");
			displayLCDNumber(1, 3, SensorValue[leftDrive]);


			displayLCDString(1, 7, "L ");
			displayLCDNumber(1, 9, SensorValue[lift]);
		}
		else if (1==1){
			displayLCDCenteredString(0, "User");
			displayLCDCenteredString(1, "Control");
		}
		else {
			// declare some string variables to hold the formatted information

			sprintf(mainBattery," %f Volts",(float)nImmediateBatteryLevel/1000.0);
			sprintf(expanderBattery," %f Volts",(float)SensorValue[power]/270.0);
			clearLCDLine(0);
			clearLCDLine(1);
			displayLCDString(0,0,mainBattery);
			displayLCDString(1,0,expanderBattery);
			// wait 1 second before reading the volts again. Just because.
			wait1Msec(1000);
		}
	}

	wait1Msec(15);

}