#include "robot-config.h"

//Creates a competition object that allows access to Competition methods.
vex::competition    Competition;

//bool to control red or blue side auto for selector
bool redSide = true;

int maxSpeed = 100;
int trevo = 0;
int joyVal = 0;

int pLastVal = 0;
//used to calculate driving distances in auton
float math_Pi = 3.1415926535897932384626433;
bool autoRunning = false;
// if 0 - down (high flag) if 1 - middle (medium flag) if 2 - up (low flag)
//angle and puncher bools
bool pLoaded = false;
int anglePos = 0;
bool angleTrigger = false;
bool doubleShot = false;

//drive bools
bool driveLockOn = false;

//scrapper bools
bool scrapperUp = false;
bool scrapperPos = false;
bool scrapperRam = false;
bool scrapperEnabled = false;
//false = in

//pid is running or not
bool pidRunning = false;
bool turnRunning;

float pidReqValue = 0; 
float tReq = 0;

//max speed for pid to go at
int pidSpeed = 0;
int tSpeed = 0;

//constants for control
float  kp = 0.3;
//float  ki = 0.0;
float  kd = 0.3;

float tKp = 0.9;
float tKd = 3.5;




//return the avg value of left encoders
float leftAvg(){
    //avg the 2 values
    return ((FrontLeft.rotation(vex::rotationUnits::deg) + 
            BackLeft.rotation(vex::rotationUnits::deg)) / 2);
}


//return the avg value of left encoders
float rightAvg(){
    //avg the 2 values
    return ((FrontRight.rotation(vex::rotationUnits::deg) + 
            BackRight.rotation(vex::rotationUnits::deg)) / 2);
}

void moveRight(int rVel){
    FrontRight.spin(vex::directionType::fwd, rVel, vex::velocityUnits::pct);
    BackRight.spin(vex::directionType::fwd, rVel, vex::velocityUnits::pct);
}

void moveLeft(int lVel){
    FrontLeft.spin(vex::directionType::fwd, lVel, vex::velocityUnits::pct);
    BackLeft.spin(vex::directionType::fwd, lVel, vex::velocityUnits::pct);
}

void resetDrive(){
    moveLeft(0);
    moveRight(0);
    FrontLeft.resetRotation();
    BackLeft.resetRotation();
    FrontRight.resetRotation();
    BackRight.resetRotation();
}

/**************************************************/
//slew rate
int accel_step = 10;
int deccel_step = 256; // no decel slew
int lSpeed = 0;
int rSpeed = 0;

void leftSlew(int leftTarget){
  int step;

  if(abs(lSpeed) < abs(leftTarget))
    step = accel_step;
  else
    step = deccel_step;

  if(leftTarget > lSpeed + step)
    lSpeed += step;
  else if(leftTarget < lSpeed - step)
    lSpeed -= step;
  else
    lSpeed = leftTarget;

  moveLeft(lSpeed);
}

//slew control
void rightSlew(int rightTarget){
  int step;

  if(abs(rSpeed) < abs(rightTarget))
    step = accel_step;
  else
    step = deccel_step;

  if(rightTarget > rSpeed + step)
    rSpeed += step;
  else if(rightTarget < rSpeed - step)
    rSpeed -= step;
  else
    rSpeed = rightTarget;

  moveRight(rSpeed);
}



//stop the pid part from running and reset values passed
//works for normal and turns
 void stopPid(){
    pidRunning = false;
   // turnRunning = false;
    moveLeft(0);
    moveRight(0);
    //redundant safeties
    pidReqValue = 0;
    pidSpeed = 0;
    //tReq = 0;
    //tSpeed = 0;
 }

 void stopTurn(){
    turnRunning = false;
    moveLeft(0);
    moveRight(0);
    tReq = 0;
    tSpeed = 0;
 }

 void startPid(float pReq, int pSpeed){ //pReq in inches
    resetDrive();
    pidReqValue = (pReq / (4 * math_Pi)) * 360;
    pidSpeed = pSpeed;
    pidRunning = true;

    //wait until pidRunning is false
    while(pidRunning){
        vex::task::sleep(20);
    }
    //Brain.Screen.printAt(1, 115, "Done!");
 }

//positive tReq = right turn!
 void startTurn(float tReq, int turSpeed){
    resetDrive();
    tReq = (tReq / (4 * math_Pi)) * 360;
    tSpeed = turSpeed;
    turnRunning = true;
    
    //wait until pidRunning is false
    while(turnRunning){
        vex::task::sleep(20);
    }
 }

int pidTask(){
    //normal
    float  pidCurrValue;
    int    pidError;
    float  pidLastError;
    float  pidDerivative;
    int    pidDrive;


    //clearEncoders
    resetDrive();

    pidLastError = 0;
     while(true){

        if(pidRunning){
            Brain.Screen.clearScreen();

            //read sensor value from Avg func
            pidCurrValue = (rightAvg() + leftAvg()) / 2;
            pidError = pidReqValue - pidCurrValue;

            pidDerivative = pidError - pidLastError;
            pidLastError = pidError;

            pidDrive = (kp * pidError) + (kd * pidDerivative);
            //limit drive - speed based on pidSpeed variable passed in
            if(pidDrive > pidSpeed)
                pidDrive = pidSpeed;
            else if(pidDrive < (-pidSpeed))
                pidDrive = (-pidSpeed);

            //stoppping state - if drive power super small, (less than 3) and error is equal to last error, robot is stopped
            if((abs(pidDrive) < 1) && ((pidLastError == pidError) || (pidError < 3))){
                stopPid();
            }    
            //send to drive motors - values already scaled to speed
            //moveLeft(pidDrive);
            //moveRight(pidDrive);
            rightSlew(pidDrive);
            leftSlew(pidDrive);
        }
        

        //pid not running
        else {
            // clear all
            pidError       = 0;
            pidLastError   = 0;
            pidDerivative  = 0;
            pidReqValue    = 0;
            pidSpeed       = 0;
        }

            //to not waste resources
            vex::task::sleep(25);
        }
        return 0;
}

int turnTask(){
    //turning
    float  tCurr;
    int    tError;
    float  tLastError;
    float  tDeriv;
    int    tDrive;


    //clearEncoders
    resetDrive();
    tLastError = 0;

     while(true){
        //turning pid
        if(turnRunning){
            Brain.Screen.clearScreen();

            //guarentees correct sign - right turn is pos, left is neg
            tCurr = (leftAvg() - rightAvg()) / 2;
            tCurr = leftAvg();
            tError = tReq - tCurr;

            pidDerivative = tError - tLastError;
            tLastError = tError;

            tDrive = (tKp * tError) + (tKd * tDeriv);
            //limit drive - speed based on pidSpeed variable passed in
            if(tDrive > tSpeed)
                tDrive = tSpeed;
            else if(tDrive < (-tSpeed))
                tDrive = (-tSpeed);

            //stoppping state - if drive power super small, (less than 3) and error is equal to last error, robot is stopped
            if((abs(tDrive) < 1) && ((tLastError == tError) || (tError < 3))){
                stopTurn();
            }    
            //send to drive motors
            //moveLeft(tDrive);
            //moveRight(-tDrive);
            leftSlew(tDrive);
            rightSlew(-tDrive);
        }

        //pid not running
        else {
            tError = 0;
            tLastError = 0;
            tDeriv = 0;
            tReq = 0;
            tSpeed = 0;
        }

            //to not waste resources
            vex::task::sleep(25);
        }
        return 0;
}

//current gyro value holding variable [used in auton]
    int currVal = 0;

    //scaling value for second gyro to match values of first
    //negative cause second gyro is upside down
    float gScale = -1.005;

    //always use 12bit value - it's more precise
    float avgGyro(){
        //avg the two drive sides (scale the second gyro)
        return gScale * Gyro2.value(vex::analogUnits::range12bit);
    }

void resetOthers(){
    Puncher.resetRotation();
    angleAdjust.resetRotation();
    Scrapper.resetRotation();
    Intake.resetRotation();
}
/*---------------------------------------------------------------------------*/
/*                          Pre-Autonomous Functions                         */
/*                                                                           */
/*  You may want to perform some actions before the competition starts.      */
/*  Do them in the following function.  You must return from this function   */
/*  or the autonomous and usercontrol tasks will not be started.  This       */
/*  function is only called once after the cortex has been powered on and    */ 
/*  not every time that the robot is disabled.                               */
/*---------------------------------------------------------------------------*/

void pre_auton( void ) {

    //reset drive encoders
    resetOthers();
    //reset all other encoders
    resetDrive();
    //calibrate gyro
    Gyro.startCalibration();
    Gyro2.startCalibration();
        //wait until done calibrating
    while(Gyro.isCalibrating() && Gyro2.isCalibrating()){
        Brain.Screen.printAt(1, 40, "Calibrating Gyros . . .");
        vex::task::sleep(100);
    }
    
    //just to make sure gyro is calibrated
    vex::task::sleep(1000);
    Brain.Screen.clearScreen();
    Brain.Screen.printAt(1, 40, "Gyros Calibrated!");
    autoSelect.resetRotation();
}
    void driveCoast(){
      FrontLeft.stop(vex::brakeType::coast);
      BackLeft.stop(vex::brakeType::coast);
      BackRight.stop(vex::brakeType::coast);
      FrontRight.stop(vex::brakeType::coast);

    }
    void driveHold(){
      FrontLeft.stop(vex::brakeType::hold);
      BackLeft.stop(vex::brakeType::hold);
      BackRight.stop(vex::brakeType::hold);
      FrontRight.stop(vex::brakeType::hold);
    }

    void ratchetBoth(){
        if(Controller1.ButtonR1.pressing()){
                //wait until released
                   while(Controller1.ButtonR1.pressing()){
                       vex::task::sleep(100);
                   }
                //run func
                   if(pLoaded){
                   pLastVal += 180;
                Puncher.rotateTo(pLastVal, vex::rotationUnits::deg, 100, vex::velocityUnits::pct, true);
                //Puncher.stop(vex::brakeType::coast);
                pLoaded = false;
                }
                else if(!pLoaded){
                    pLastVal += 180;
                Puncher.rotateTo(pLastVal, vex::rotationUnits::deg, 100, vex::velocityUnits::pct, true);
                //Puncher.stop(vex::brakeType::coast);
                pLoaded = true;
                }
           }
    }

    void ratchetFull(){
        if(Controller1.ButtonR2.pressing()){
                //wait until released
                   while(Controller1.ButtonR2.pressing()){
                       vex::task::sleep(100);
                   }
                //run func
                pLastVal += 360;
                Puncher.rotateTo(pLastVal, vex::rotationUnits::deg, 100, vex::velocityUnits::pct, true);
           }
    }

    void doubleShotRun(){
        if(Controller1.ButtonDown.pressing()){
                //wait until released
                   while(Controller1.ButtonDown.pressing()){
                       vex::task::sleep(100);
                   }//pLastVal += 360;


                //run sequence

                   doubleShot = true;
                   //reset angle-adjuster
                angleAdjust.rotateTo(0, vex::rotationUnits::deg,100,vex::velocityUnits::pct, true);
                angleAdjust.setTimeout(600, vex::timeUnits::msec);
                
                   //if loaded back
                   if((pLastVal % 360) == 180){
                    //push pLasVal to full rotation - off by 180 in this case
                    pLastVal += 180;

                    Puncher.rotateTo(pLastVal, vex::rotationUnits::deg, 100, vex::velocityUnits::pct, true);
                    Puncher.setTimeout(1000, vex::timeUnits::msec);
                   }
                   else if((pLastVal % 360) == 0){
                    pLastVal += 360;
                    Puncher.rotateTo(pLastVal, vex::rotationUnits::deg, 100, vex::velocityUnits::pct, true);
                    Puncher.setTimeout(1000, vex::timeUnits::msec);
                   }

                   //first shot done, and puncher at non loaded position
                    

                    //load ball up
                   // Intake.rotateFor(1, vex::rotationUnits::rev, (maxSpeed), vex::velocityUnits::pct, true);
                   // Intake.setTimeout(1000, vex::timeUnits::msec);

                    //load ball more, but don't wait for it
                    Intake.rotateFor(6, vex::rotationUnits::rev, (maxSpeed), vex::velocityUnits::pct, false);
                    Intake.setTimeout(1000, vex::timeUnits::msec);

                    //change angle
                    angleAdjust.rotateTo(140, vex::rotationUnits::deg,100,vex::velocityUnits::pct, true);
                    angleAdjust.setTimeout(600, vex::timeUnits::msec);

                  //  vex::task::sleep(100);

                    pLastVal += 360;
                    Puncher.rotateTo(pLastVal, vex::rotationUnits::deg, 100, vex::velocityUnits::pct, true);
                    Puncher.setTimeout(1000, vex::timeUnits::msec);

                    angleAdjust.rotateTo(0, vex::rotationUnits::deg,100,vex::velocityUnits::pct, true);
                    angleAdjust.setTimeout(600, vex::timeUnits::msec);

                    doubleShot = false;
           }
    }



void ratchetTaskFunc(){

    if(!autoRunning){
    Puncher.stop(vex::brakeType::coast);
    }

    ratchetBoth();
    ratchetFull();
    doubleShotRun();
}

    
//other task used to run puncher and cap intake triggers
    
int ratchetTask(){
     while(true){
            ratchetTaskFunc();
            //to not waste resources
            vex::task::sleep(20);
        }
        return 0;
}
    
    //function to toggle lock and coast with boolean
    void driveLock(bool z){
        // if z is true, lock is turned on
        // else, it's turned off
        if(z){
            driveHold(); 
        }
        else if(!z) {
            driveCoast();
        }
    }

    //d in inches
    //s speed - in pct out of %100
    void driveMoveFor(float d, int s){
        resetDrive();
        driveLock(false);
        //calculate distance from inches to revolutions
        float revo = d / (4 * math_Pi);
        FrontLeft.rotateFor(revo, vex::rotationUnits::rev, s, vex::velocityUnits::pct, false);
        FrontRight.rotateFor(revo, vex::rotationUnits::rev, s, vex::velocityUnits::pct, false);
        BackLeft.rotateFor(revo, vex::rotationUnits::rev, s, vex::velocityUnits::pct, false);
        BackRight.rotateFor(revo, vex::rotationUnits::rev, s, vex::velocityUnits::pct, true);
        //driveLock(true);
    }
    
  //turning without gyro - swing turns
    //left dist in inches - negative for backwards
    //right dist in inches
    //left speed in pct
    //right speed in pct
    void driveTurnFor(float leftdist, float rightddist, int leftSpeed, int rightSpeed){
        resetDrive();
        driveLock(true);
        float Lrevo = leftdist / (4 * math_Pi);
        float Rrevo = rightddist / (4 * math_Pi);
        FrontLeft.rotateFor(Lrevo, vex::rotationUnits::rev, leftSpeed, vex::velocityUnits::pct, false);
        BackLeft.rotateFor(Lrevo, vex::rotationUnits::rev, leftSpeed, vex::velocityUnits::pct, false);
        FrontRight.rotateFor(Rrevo, vex::rotationUnits::rev, rightSpeed, vex::velocityUnits::pct, false);
        BackRight.rotateFor(Rrevo, vex::rotationUnits::rev, rightSpeed, vex::velocityUnits::pct, true);
        driveLock(true);
    }

    //timeout drive for time
    void driveTimeout(float leftTime, float rightTime){
        FrontLeft.setTimeout(leftTime, vex::timeUnits::sec);
        BackLeft.setTimeout(leftTime, vex::timeUnits::sec);
        FrontRight.setTimeout(rightTime, vex::timeUnits::sec);
        BackRight.setTimeout(rightTime, vex::timeUnits::sec);
    }
        /*-------------------------------------------------------------------------------------------*/
        /*                                                                                           */
        /*                                                                                           */
        /*  Red Auton .                                                                              */
        /*                                                                                           */
        /*                                                                                           */
        /*-------------------------------------------------------------------------------------------*/
    
    void threeFlagRed(){

        angleAdjust.setStopping(vex::brakeType::hold);

        angleAdjust.resetRotation();
        Puncher.resetRotation();
        //reset driveTrain encoders
        resetDrive();
        resetOthers();
        //start intake
        Intake.spin(vex::directionType::fwd, (maxSpeed * 1), vex::velocityUnits::pct);
        //preLoad puncher with ratchet
        Puncher.rotateTo(180, vex::rotationUnits::deg, 100, vex::velocityUnits::pct, false);
        Puncher.setTimeout(600, vex::timeUnits::msec);


        //run drive forward for 34 inches
        //driveMoveFor(36, 60);
        startPid(32, 60);

        //wait to intake ball
        vex::task::sleep(150); 

        //slow intake down so ball doesn't get yeet
        Intake.spin(vex::directionType::fwd, (maxSpeed * 0.4), vex::velocityUnits::pct);
                
        resetDrive();


        //drive back
        startPid(-35.5, 75);
        resetDrive();
        //Intake.spin(vex::directionType::fwd, (maxSpeed * 0.3), vex::velocityUnits::pct);

        //hold lift up
        //Lift.stop(vex::brakeType::hold);

        //settle down
        

        //stop intake
        //put ball down
        //vex::task::sleep(200);

       Intake.rotateFor(-2, vex::rotationUnits::rev, (maxSpeed), vex::velocityUnits::pct, false);
       Intake.setTimeout(1000, vex::timeUnits::msec);

        //angle-adjust for high flag
        angleAdjust.rotateTo(20, vex::rotationUnits::deg,100,vex::velocityUnits::pct, false);
        angleAdjust.setTimeout(600, vex::timeUnits::msec);

        //drive forward for flag alignment before turning
        //less driving for new strat
        //driveMoveFor(8.75, 45);
       // driveMoveFor(6, 40);
       // driveTimeout(1, 1);

        resetDrive();

        //turn to face flags with pid
        vex::task::sleep(100);
        /*        
        currVal = avgGyro();
        FrontLeft.spin(vex::directionType::rev, 40, vex::velocityUnits::pct);
        BackLeft.spin(vex::directionType::rev, 40, vex::velocityUnits::pct);
        BackRight.spin(vex::directionType::fwd, 40, vex::velocityUnits::pct);
        FrontRight.spin(vex::directionType::fwd, 40, vex::velocityUnits::pct);

        while(((avgGyro() - currVal) > -840)){
           vex::task::sleep(10); 
        }
        //stop motors with PID
        driveHold();
        driveTimeout(2, 2); 
        //stop motors and put them on coast
        vex::task::sleep(150);
        driveCoast();
        */

        //testing pid turn
        startTurn(-9.2, 50);

        //pull back slipgear just enough to shoot
        Puncher.rotateTo(360, vex::rotationUnits::deg, 100, vex::velocityUnits::pct, true);
        Puncher.setTimeout(1000, vex::timeUnits::msec);
        Puncher.stop(vex::brakeType::coast);

        //get next ball up
        Intake.rotateFor(4, vex::rotationUnits::rev, (maxSpeed), vex::velocityUnits::pct, false);
        vex::task::sleep(100);
        //change angle
        angleAdjust.rotateTo(145, vex::rotationUnits::deg,100,vex::velocityUnits::pct, false);
        angleAdjust.setTimeout(600, vex::timeUnits::msec);
        //give ball a little bit of time

        //shoot second ball
        vex::task::sleep(300);
        Puncher.rotateTo(720, vex::rotationUnits::deg, 100, vex::velocityUnits::pct, true);
        Puncher.setTimeout(1000, vex::timeUnits::msec);
        Puncher.stop(vex::brakeType::coast);
        vex::task::sleep(300);
        angleAdjust.rotateTo(0, vex::rotationUnits::deg,100,vex::velocityUnits::pct, false);
        angleAdjust.setTimeout(600, vex::timeUnits::msec);

        Intake.spin(vex::directionType::fwd, (-1 * maxSpeed), vex::velocityUnits::pct);

        startTurn(-0.4, 30);
        vex::task::sleep(100);
        startPid(32, 90);
       // startPid(31.6, 95, 30, 90);
        //startPid(31, 90, 32.7, 95);
        //vex::task::sleep(200);

        //put scrapper out for low flag
        Scrapper.rotateTo(-180, vex::rotationUnits::deg, 100, vex::velocityUnits::pct, true);
        Scrapper.setTimeout(750, vex::timeUnits::msec);
        vex::task::sleep(200);
        Scrapper.rotateTo(0, vex::rotationUnits::deg, 100, vex::velocityUnits::pct, false);
        Scrapper.setTimeout(750, vex::timeUnits::msec);
        startPid(-28, 90);
        Intake.spin(vex::directionType::fwd, (0), vex::velocityUnits::pct);


        vex::task::sleep(100);
        startTurn(-5.5, 50);

        //startPid(5.8, 30, -5.8, 30);
        /*
        currVal = avgGyro();
        FrontLeft.spin(vex::directionType::fwd, 40, vex::velocityUnits::pct);
        BackLeft.spin(vex::directionType::fwd, 40, vex::velocityUnits::pct);
        BackRight.spin(vex::directionType::rev, 40, vex::velocityUnits::pct);
        FrontRight.spin(vex::directionType::rev, 40, vex::velocityUnits::pct);

        //less turning with new strat -old: 890
        //while(((Gyro.value(vex::analogUnits::range12bit)) - currVal) > -825){
          // vex::task::sleep(10); 
       // }
        while(((avgGyro() - currVal) < 480)){
           vex::task::sleep(10); 
        }
        //stop motors with PID
        driveHold();
        driveTimeout(2, 2); 
        //stop motors and put them on coast
        vex::task::sleep(150);
        driveCoast();
        */

        Puncher.rotateTo(900, vex::rotationUnits::deg, 100, vex::velocityUnits::pct, false);
        Puncher.setTimeout(600, vex::timeUnits::msec);

        

        startPid(8, 50);
        angleAdjust.stop(vex::brakeType::hold);

        Scrapper.rotateTo(-430, vex::rotationUnits::deg, 100, vex::velocityUnits::pct, true);
        Scrapper.setTimeout(750, vex::timeUnits::msec);

        Intake.spin(vex::directionType::fwd, (maxSpeed), vex::velocityUnits::pct);

        vex::task::sleep(350);

        //Intake.spin(vex::directionType::fwd, (maxSpeed * 0.75), vex::velocityUnits::pct);

        startPid(-13.5, 60);

        Scrapper.rotateTo(-560, vex::rotationUnits::deg, 100, vex::velocityUnits::pct, false);
        Scrapper.setTimeout(750, vex::timeUnits::msec);

       // Scrapper.rotateTo(-570, vex::rotationUnits::deg, 100, vex::velocityUnits::pct, false);
      //  Scrapper.setTimeout(750, vex::timeUnits::msec);

       //

        startPid(9, 40);

        vex::task::sleep(200);
        Intake.spin(vex::directionType::fwd, (maxSpeed * 0.0), vex::velocityUnits::pct);
        vex::task::sleep(100);

        angleAdjust.rotateTo(145, vex::rotationUnits::deg,100,vex::velocityUnits::pct, true);
        angleAdjust.setTimeout(600, vex::timeUnits::msec);

        //Intake.spin(vex::directionType::fwd, (maxSpeed * 0.5), vex::velocityUnits::pct);

       // startPid(10, 50, 10, 50);
       Intake.rotateFor(-3, vex::rotationUnits::rev, (maxSpeed), vex::velocityUnits::pct, true);
       Intake.setTimeout(1000, vex::timeUnits::msec);
       // Intake.rotateFor(-1, vex::rotationUnits::rev, (maxSpeed * .80), vex::velocityUnits::pct, true);
        Scrapper.rotateTo(-430, vex::rotationUnits::deg, 100, vex::velocityUnits::pct, false);
        Scrapper.setTimeout(750, vex::timeUnits::msec);

        Puncher.rotateTo(1080, vex::rotationUnits::deg, 100, vex::velocityUnits::pct, true);
        Puncher.setTimeout(1000, vex::timeUnits::msec);
        Puncher.stop(vex::brakeType::coast);

        

//        Scrapper.rotateTo(-350, vex::rotationUnits::deg, 100, vex::velocityUnits::pct, false);
  //      Scrapper.setTimeout(750, vex::timeUnits::msec);
        //get next ball up
        Intake.rotateFor(3.5, vex::rotationUnits::rev, (maxSpeed * .80), vex::velocityUnits::pct, false);
        //change angle
        angleAdjust.rotateTo(50, vex::rotationUnits::deg,100,vex::velocityUnits::pct, false);
        angleAdjust.setTimeout(600, vex::timeUnits::msec);
        //give ball a little bit of time

        //shoot second ball
        vex::task::sleep(300);
        Puncher.rotateTo(1440, vex::rotationUnits::deg, 100, vex::velocityUnits::pct, true);
        Puncher.setTimeout(1000, vex::timeUnits::msec);
        Puncher.stop(vex::brakeType::coast);

        angleAdjust.rotateTo(0, vex::rotationUnits::deg,100,vex::velocityUnits::pct, false);
        angleAdjust.setTimeout(600, vex::timeUnits::msec);

       // startPid(8, 90, 8, 90);
       // Scrapper.rotateTo(0, vex::rotationUnits::deg, 65, vex::velocityUnits::pct, true);
      //  Scrapper.setTimeout(750, vex::timeUnits::msec);

        Puncher.stop(vex::brakeType::coast);
        Intake.stop(vex::brakeType::coast);
        driveLock(false);

    }
    

        /*-------------------------------------------------------------------------------------------*/
        /*                                                                                           */
        /*                                                                                           */
        /*  Blue Auton                                                                               */
        /*                                                                                           */
        /*                                                                                           */
        /*-------------------------------------------------------------------------------------------*/

    //same as threeFlagRed, but blue
    //if all false, run 3 flag with cap flip
    //if four flag, run 3 flag with cap flip and middle pole low flag
    //if five flag, run 3 flag with cap flip, high flag shot, and middle pole low flag
    //if park, run 3 flag with cap flip and park
    void threeFlagBlue(){/*
        angleAdjust.setStopping(vex::brakeType::hold);

        angleAdjust.resetRotation();
        Puncher.resetRotation();
        //reset driveTrain encoders
        resetDrive();
        resetOthers();
        //start intake
        Intake.spin(vex::directionType::fwd, (maxSpeed * 1), vex::velocityUnits::pct);
        //preLoad puncher with ratchet
        Puncher.rotateTo(180, vex::rotationUnits::deg, 100, vex::velocityUnits::pct, false);
        Puncher.setTimeout(600, vex::timeUnits::msec);


        //run drive forward for 34 inches
        //driveMoveFor(36, 60);
        startPid(32, 60, 32, 60);

        //wait to intake ball
        vex::task::sleep(150); 

        //slow intake down so ball doesn't get yeet
        Intake.spin(vex::directionType::fwd, (maxSpeed * 0.0), vex::velocityUnits::pct);
                
        resetDrive();
        //lift up so it doesn't hit field wall
        //Lift.rotateTo(340, vex::rotationUnits::deg, 85, vex::velocityUnits::pct, false);
        //Lift.setTimeout(1000, vex::timeUnits::msec);

        //hit field wall and realign with swing turn
        //driveTurnFor(-46, -46.5, 80, 75);
        //driveTurnFor(-36.2, -36.2, 80, 80);

        //drive back

        

        startPid(-33.5, 75, -33.5, 75);


        resetDrive();
        //Intake.spin(vex::directionType::fwd, (maxSpeed * 0.3), vex::velocityUnits::pct);

        //hold lift up
        //Lift.stop(vex::brakeType::hold);

        //settle down
        

        //stop intake
        //put ball down
        //vex::task::sleep(200);

       //Intake.rotateFor(-2, vex::rotationUnits::rev, (maxSpeed), vex::velocityUnits::pct, false);
       //Intake.setTimeout(1000, vex::timeUnits::msec);

        //angle-adjust for high flag
        angleAdjust.rotateTo(20, vex::rotationUnits::deg,100,vex::velocityUnits::pct, false);
        angleAdjust.setTimeout(600, vex::timeUnits::msec);

        //drive forward for flag alignment before turning
        //less driving for new strat
        //driveMoveFor(8.75, 45);
       // driveMoveFor(6, 40);
       // driveTimeout(1, 1);

        resetDrive();

        //turn to face flags with pid
        vex::task::sleep(100);
        //startPid(-9.6, 40, 9.6, 40);

        currVal = avgGyro();
        FrontLeft.spin(vex::directionType::fwd, 40, vex::velocityUnits::pct);
        BackLeft.spin(vex::directionType::fwd, 40, vex::velocityUnits::pct);
        BackRight.spin(vex::directionType::rev, 40, vex::velocityUnits::pct);
        FrontRight.spin(vex::directionType::rev, 40, vex::velocityUnits::pct);

        //less turning with new strat -old: 890
        //while(((Gyro.value(vex::analogUnits::range12bit)) - currVal) > -825){
          // vex::task::sleep(10); 
       // }
        while(((avgGyro() - currVal) < 860)){
           vex::task::sleep(10); 
        }
        //stop motors with PID
        driveHold();
        driveTimeout(2, 2); 
        //stop motors and put them on coast
        vex::task::sleep(150);
        driveCoast();

        ////drive forward to align front and back for top flag - puncher has already started
        //drive forward to align front and back for top flag - puncher has already preloaded

        //no driving cause angle-adjusting
        //driveMoveFor(8, 50);
        //driveTimeout(1, 1); 

        //pull back slipgear just enough to shoot

        Puncher.rotateTo(360, vex::rotationUnits::deg, 100, vex::velocityUnits::pct, true);
        Puncher.setTimeout(1000, vex::timeUnits::msec);
        Puncher.stop(vex::brakeType::coast);


        //get next ball up
        Intake.rotateFor(3, vex::rotationUnits::rev, (maxSpeed * .6), vex::velocityUnits::pct, false);
        vex::task::sleep(100);
        //change angle
        angleAdjust.rotateTo(145, vex::rotationUnits::deg,100,vex::velocityUnits::pct, false);
        angleAdjust.setTimeout(600, vex::timeUnits::msec);
        //give ball a little bit of time

        //shoot second ball
        vex::task::sleep(300);
        Puncher.rotateTo(720, vex::rotationUnits::deg, 100, vex::velocityUnits::pct, true);
        Puncher.setTimeout(1000, vex::timeUnits::msec);
        Puncher.stop(vex::brakeType::coast);
        vex::task::sleep(300);
        angleAdjust.rotateTo(0, vex::rotationUnits::deg,100,vex::velocityUnits::pct, false);
        angleAdjust.setTimeout(600, vex::timeUnits::msec);

        Intake.spin(vex::directionType::fwd, (-1 * maxSpeed), vex::velocityUnits::pct);

        startPid(31.6, 95, 30, 90);
        //vex::task::sleep(200);

        //put scrapper out for low flag
        Scrapper.rotateTo(-180, vex::rotationUnits::deg, 100, vex::velocityUnits::pct, true);
        Scrapper.setTimeout(750, vex::timeUnits::msec);
        vex::task::sleep(200);
        Scrapper.rotateTo(0, vex::rotationUnits::deg, 100, vex::velocityUnits::pct, false);
        Scrapper.setTimeout(750, vex::timeUnits::msec);
        startPid(-28, 90, -28, 90);
        Intake.spin(vex::directionType::fwd, (0), vex::velocityUnits::pct);


        //vex::task::sleep(200);


        //startPid(5.8, 30, -5.8, 30);
        currVal = avgGyro();
        FrontLeft.spin(vex::directionType::rev, 40, vex::velocityUnits::pct);
        BackLeft.spin(vex::directionType::rev, 40, vex::velocityUnits::pct);
        BackRight.spin(vex::directionType::fwd, 40, vex::velocityUnits::pct);
        FrontRight.spin(vex::directionType::fwd, 40, vex::velocityUnits::pct);

        //less turning with new strat -old: 890
        //while(((Gyro.value(vex::analogUnits::range12bit)) - currVal) > -825){
          // vex::task::sleep(10); 
       // }
        while(((avgGyro() - currVal) > -480)){
           vex::task::sleep(10); 
        }
        //stop motors with PID
        driveHold();
        driveTimeout(2, 2); 
        //stop motors and put them on coast
        vex::task::sleep(150);
        driveCoast();



        Puncher.rotateTo(900, vex::rotationUnits::deg, 100, vex::velocityUnits::pct, false);
        Puncher.setTimeout(600, vex::timeUnits::msec);

        

        startPid(8, 50, 8, 50);
        angleAdjust.stop(vex::brakeType::hold);

        Scrapper.rotateTo(-430, vex::rotationUnits::deg, 100, vex::velocityUnits::pct, true);
        Scrapper.setTimeout(750, vex::timeUnits::msec);

        Intake.spin(vex::directionType::fwd, (maxSpeed), vex::velocityUnits::pct);

        vex::task::sleep(350);

        Intake.spin(vex::directionType::fwd, (maxSpeed * 0.75), vex::velocityUnits::pct);

        startPid(-13.5, 60, -13.5, 60);

        Scrapper.rotateTo(-560, vex::rotationUnits::deg, 100, vex::velocityUnits::pct, false);
        Scrapper.setTimeout(750, vex::timeUnits::msec);

       // Scrapper.rotateTo(-570, vex::rotationUnits::deg, 100, vex::velocityUnits::pct, false);
      //  Scrapper.setTimeout(750, vex::timeUnits::msec);

       //

        startPid(9, 40, 9, 40);

        vex::task::sleep(200);
        Intake.spin(vex::directionType::fwd, (maxSpeed * 0.3), vex::velocityUnits::pct);
        vex::task::sleep(300);

        angleAdjust.rotateTo(145, vex::rotationUnits::deg,100,vex::velocityUnits::pct, true);
        angleAdjust.setTimeout(600, vex::timeUnits::msec);

        //Intake.spin(vex::directionType::fwd, (maxSpeed * 0.5), vex::velocityUnits::pct);

       // startPid(10, 50, 10, 50);
       Intake.rotateFor(-2, vex::rotationUnits::rev, (maxSpeed), vex::velocityUnits::pct, true);
       Intake.setTimeout(1000, vex::timeUnits::msec);
       // Intake.rotateFor(-1, vex::rotationUnits::rev, (maxSpeed * .80), vex::velocityUnits::pct, true);
        Scrapper.rotateTo(-430, vex::rotationUnits::deg, 100, vex::velocityUnits::pct, false);
        Scrapper.setTimeout(750, vex::timeUnits::msec);

        Puncher.rotateTo(1080, vex::rotationUnits::deg, 100, vex::velocityUnits::pct, true);
        Puncher.setTimeout(1000, vex::timeUnits::msec);
        Puncher.stop(vex::brakeType::coast);

        

//        Scrapper.rotateTo(-350, vex::rotationUnits::deg, 100, vex::velocityUnits::pct, false);
  //      Scrapper.setTimeout(750, vex::timeUnits::msec);
        //get next ball up
        Intake.rotateFor(3.5, vex::rotationUnits::rev, (maxSpeed * .80), vex::velocityUnits::pct, false);
        //change angle
        angleAdjust.rotateTo(50, vex::rotationUnits::deg,100,vex::velocityUnits::pct, false);
        angleAdjust.setTimeout(600, vex::timeUnits::msec);
        //give ball a little bit of time

        //shoot second ball
        vex::task::sleep(300);
        Puncher.rotateTo(1440, vex::rotationUnits::deg, 100, vex::velocityUnits::pct, true);
        Puncher.setTimeout(1000, vex::timeUnits::msec);
        Puncher.stop(vex::brakeType::coast);

        angleAdjust.rotateTo(0, vex::rotationUnits::deg,100,vex::velocityUnits::pct, false);
        angleAdjust.setTimeout(600, vex::timeUnits::msec);

       // startPid(8, 90, 8, 90);
       // Scrapper.rotateTo(0, vex::rotationUnits::deg, 65, vex::velocityUnits::pct, true);
      //  Scrapper.setTimeout(750, vex::timeUnits::msec);

        Puncher.stop(vex::brakeType::coast);
        Intake.stop(vex::brakeType::coast);
        driveLock(false);
        */
    }

    void backRedMiddle(){
        /*
        resetDrive();
        resetOthers();
        //start intake
        Intake.spin(vex::directionType::fwd, (maxSpeed), vex::velocityUnits::pct);

        //run drive forward for 36 inches
        startPid(31, 60, 31, 60);
        //wait to intake ball
        vex::task::sleep(450); 

        //slow intake down so ball doesn't get yeet
        Intake.spin(vex::directionType::fwd, (maxSpeed * 0.2), vex::velocityUnits::pct);  

        resetDrive();

        //drive back a little
        //startPid(-1.5, 40, -1.5, 40);

        //now that we have the ball, put it down a little before we shoot
        //Intake.rotateFor(-1.5, vex::rotationUnits::rev, (maxSpeed), vex::velocityUnits::pct, false);
        //Intake.setTimeout(1000, vex::timeUnits::msec);

        vex::task::sleep(1000); 

        Intake.spin(vex::directionType::fwd, (0), vex::velocityUnits::pct);  


        startPid(2, 40, 2, 40);

        Intake.rotateFor(-2, vex::rotationUnits::rev, (maxSpeed * .80), vex::velocityUnits::pct, true);
        //turn left to face alliance platform
        currVal = avgGyro();
        FrontLeft.spin(vex::directionType::rev, 40, vex::velocityUnits::pct);
        BackLeft.spin(vex::directionType::rev, 40, vex::velocityUnits::pct);
        BackRight.spin(vex::directionType::fwd, 40, vex::velocityUnits::pct);
        FrontRight.spin(vex::directionType::fwd, 40, vex::velocityUnits::pct);

        //less turning with new strat -old: 890
        //while(((Gyro.value(vex::analogUnits::range12bit)) - currVal) > -825){
          // vex::task::sleep(10); 
       // }
        while(((avgGyro() - currVal) > -860)){
           vex::task::sleep(10); 
        }
        //stop motors with PID
        driveHold();
        driveTimeout(2, 2); 
        //stop motors and put them on coast
        vex::task::sleep(150);
        driveCoast();

        vex::task::sleep(300); 

        //prepull back puncher for shooting later on
        Puncher.rotateTo(180, vex::rotationUnits::deg, 100, vex::velocityUnits::pct, false);
        Puncher.setTimeout(600, vex::timeUnits::msec);

        //angle adjust ahead of time for first shot
        angleAdjust.rotateTo(75, vex::rotationUnits::deg, 100,vex::velocityUnits::pct, false);
        angleAdjust.setTimeout(600, vex::timeUnits::msec);

        //drive forward to align against low platform
        //startPid(5, 40, 5, 40);
        driveMoveFor(5, 40);

        vex::task::sleep(300); 

        //move right side backwards to slowly align with flags
        currVal = avgGyro();
        
        BackRight.spin(vex::directionType::rev, 25, vex::velocityUnits::pct);
        FrontRight.spin(vex::directionType::rev, 25, vex::velocityUnits::pct);

        //less turning with new strat -old: 890
        //while(((Gyro.value(vex::analogUnits::range12bit)) - currVal) > -825){
          // vex::task::sleep(10); 
       // }
        while(((avgGyro() - currVal) < 80)){
           vex::task::sleep(10); 
        }
        //stop motors with PID
        driveHold();
        driveTimeout(2, 2); 
        //stop motors and put them on coast
        vex::task::sleep(150);
        driveCoast();

        //aligned, so shoot both flags
        vex::task::sleep(3900); 
        //first shot would be too high, but we're already angle adjusted
        Puncher.rotateTo(360, vex::rotationUnits::deg, 100, vex::velocityUnits::pct, true);
        Puncher.setTimeout(1000, vex::timeUnits::msec);
        Puncher.stop(vex::brakeType::coast);

        //next ball up
        Intake.rotateFor(5, vex::rotationUnits::rev, (maxSpeed * .80), vex::velocityUnits::pct, false);
        vex::task::sleep(100);

        //angle adjust to medium height
        angleAdjust.rotateTo(155, vex::rotationUnits::deg,100,vex::velocityUnits::pct, true);
        angleAdjust.setTimeout(600, vex::timeUnits::msec);
        
        vex::task::sleep(100);

        //shoot next shot
        Puncher.rotateTo(720, vex::rotationUnits::deg, 100, vex::velocityUnits::pct, true);
        Puncher.setTimeout(1000, vex::timeUnits::msec);
        Puncher.stop(vex::brakeType::coast);
        vex::task::sleep(100);

        //reset angle-adjuster for start of match
        angleAdjust.rotateTo(0,vex::rotationUnits::deg,100,vex::velocityUnits::pct, false);
        angleAdjust.setTimeout(600, vex::timeUnits::msec);

        //stop intake (just in case)
        Intake.stop(vex::brakeType::coast);
        resetDrive();

        //move right side backwards to slowly align with flags
        currVal = avgGyro();
        
        BackRight.spin(vex::directionType::fwd, 40, vex::velocityUnits::pct);
        FrontRight.spin(vex::directionType::fwd, 40, vex::velocityUnits::pct);

        //less turning with new strat -old: 890
        //while(((Gyro.value(vex::analogUnits::range12bit)) - currVal) > -825){
          // vex::task::sleep(10); 
       // }
        while(((avgGyro() - currVal) > -80)){
           vex::task::sleep(10); 
        }
        //stop motors with PID
        driveHold();
        driveTimeout(2, 2); 
        //stop motors and put them on coast
        vex::task::sleep(150);
        driveCoast();

        //drive back a little before charging up platform
       // startPid(-11, 60, -11, 60);
        vex::task::sleep(300);

        Scrapper.rotateTo(-475, vex::rotationUnits::deg, 100, vex::velocityUnits::pct, true);
        Scrapper.setTimeout(750, vex::timeUnits::msec);
        //drive up platform
        startPid(27, 100, 27, 100);
        Scrapper.rotateTo(0, vex::rotationUnits::deg, 100, vex::velocityUnits::pct, true);
        Scrapper.setTimeout(750, vex::timeUnits::msec);
        */
    }
    void backBlueMiddle(){/*
        resetDrive();
        resetOthers();
        //start intake
        Intake.spin(vex::directionType::fwd, (maxSpeed * 0.8), vex::velocityUnits::pct);

        //run drive forward for 36 inches
        startPid(35, 60, 35, 60);
        //wait to intake ball
        vex::task::sleep(100); 

        //slow intake down so ball doesn't get yeet
        Intake.spin(vex::directionType::fwd, (maxSpeed * 0.2), vex::velocityUnits::pct);  

        resetDrive();

        //drive back a little
        startPid(-3.5, 40, -3.5, 40);

        //now that we have the ball, put it down a little before we shoot
        //Intake.rotateFor(-1.5, vex::rotationUnits::rev, (maxSpeed), vex::velocityUnits::pct, false);
        //Intake.setTimeout(1000, vex::timeUnits::msec);

        vex ::task::sleep(500); 

        Intake.rotateFor(-2, vex::rotationUnits::rev, (maxSpeed * .80), vex::velocityUnits::pct, true);
        //turn left to face alliance platform
        currVal = avgGyro();
        FrontLeft.spin(vex::directionType::fwd, 40, vex::velocityUnits::pct);
        BackLeft.spin(vex::directionType::fwd, 40, vex::velocityUnits::pct);
        BackRight.spin(vex::directionType::rev, 40, vex::velocityUnits::pct);
        FrontRight.spin(vex::directionType::rev, 40, vex::velocityUnits::pct);

        //less turning with new strat -old: 890
        //while(((Gyro.value(vex::analogUnits::range12bit)) - currVal) > -825){
          // vex::task::sleep(10); 
       // }
        while(((avgGyro() - currVal) < 800)){
           vex::task::sleep(10); 
        }
        //stop motors with PID
        driveHold();
        driveTimeout(2, 2); 
        //stop motors and put them on coast
        vex::task::sleep(150);
        driveCoast();

        vex::task::sleep(300); 

        //prepull back puncher for shooting later on
        Puncher.rotateTo(180, vex::rotationUnits::deg, 100, vex::velocityUnits::pct, false);
        Puncher.setTimeout(600, vex::timeUnits::msec);

        //angle adjust ahead of time for first shot
        angleAdjust.rotateTo(40, vex::rotationUnits::deg, 100,vex::velocityUnits::pct, false);
        angleAdjust.setTimeout(600, vex::timeUnits::msec);

        //drive forward to align against low platform
        //startPid(5, 40, 5, 40);
        driveMoveFor(5, 40);

        vex::task::sleep(300); 

        //move right side backwards to slowly align with flags
        currVal = avgGyro();
        
        BackLeft.spin(vex::directionType::rev, 25, vex::velocityUnits::pct);
        FrontLeft.spin(vex::directionType::rev, 25, vex::velocityUnits::pct);

        //less turning with new strat -old: 890
        //while(((Gyro.value(vex::analogUnits::range12bit)) - currVal) > -825){
          // vex::task::sleep(10); 
       // }
        while(((avgGyro() - currVal) > -65)){
           vex::task::sleep(10); 
        }
        //stop motors with PID
        driveHold();
        driveTimeout(2, 2); 
        //stop motors and put them on coast
        vex::task::sleep(150);
        driveCoast();

        //aligned, so shoot both flags
        vex::task::sleep(4600); 
        //first shot would be too high, but we're already angle adjusted
        Puncher.rotateTo(360, vex::rotationUnits::deg, 100, vex::velocityUnits::pct, true);
        Puncher.setTimeout(1000, vex::timeUnits::msec);
        Puncher.stop(vex::brakeType::coast);

        //next ball up
        Intake.rotateFor(5, vex::rotationUnits::rev, (maxSpeed * .80), vex::velocityUnits::pct, false);
        vex::task::sleep(100);

        //angle adjust to medium height
        angleAdjust.rotateTo(130, vex::rotationUnits::deg,100,vex::velocityUnits::pct, true);
        angleAdjust.setTimeout(600, vex::timeUnits::msec);
        
        vex::task::sleep(100);

        //shoot next shot
        Puncher.rotateTo(720, vex::rotationUnits::deg, 100, vex::velocityUnits::pct, true);
        Puncher.setTimeout(1000, vex::timeUnits::msec);
        Puncher.stop(vex::brakeType::coast);
        vex::task::sleep(100);

        //reset angle-adjuster for start of match
        angleAdjust.rotateTo(0,vex::rotationUnits::deg,100,vex::velocityUnits::pct, false);
        angleAdjust.setTimeout(600, vex::timeUnits::msec);

        //stop intake (just in case)
        Intake.stop(vex::brakeType::coast);
        resetDrive();

        //move right side backwards to slowly align with flags
        currVal = avgGyro();
        
        BackLeft.spin(vex::directionType::fwd, 40, vex::velocityUnits::pct);
        FrontLeft.spin(vex::directionType::fwd, 40, vex::velocityUnits::pct);

        //less turning with new strat -old: 890
        //while(((Gyro.value(vex::analogUnits::range12bit)) - currVal) > -825){
          // vex::task::sleep(10); 
       // }
        while(((avgGyro() - currVal) < 65)){
           vex::task::sleep(10); 
        }
        //stop motors with PID
        driveHold();
        driveTimeout(2, 2); 
        //stop motors and put them on coast
        vex::task::sleep(150);
        driveCoast();

        //drive back a little before charging up platform
       // startPid(-11, 60, -11, 60);
        vex::task::sleep(300);

        Scrapper.rotateTo(-475, vex::rotationUnits::deg, 100, vex::velocityUnits::pct, true);
        Scrapper.setTimeout(750, vex::timeUnits::msec);
        //drive up platform
        startPid(27, 100, 27, 100);
        Scrapper.rotateTo(0, vex::rotationUnits::deg, 100, vex::velocityUnits::pct, true);
        Scrapper.setTimeout(750, vex::timeUnits::msec);
*/
    }

    //same as middle auto, but shoots cross court to descore other side
    void backRedFar(){
        /*
        resetDrive();
        resetOthers();
        //start intake
        Intake.spin(vex::directionType::fwd, (maxSpeed), vex::velocityUnits::pct);

        //run drive forward for 36 inches
        startPid(32, 60, 32, 60);
        //wait to intake ball
        vex::task::sleep(350); 

        //slow intake down so ball doesn't get yeet
        Intake.spin(vex::directionType::fwd, (maxSpeed * 0.2), vex::velocityUnits::pct);  

        resetDrive();

        //drive back a little
        //startPid(-1.5, 40, -1.5, 40);

        //now that we have the ball, put it down a little before we shoot
        //Intake.rotateFor(-1.5, vex::rotationUnits::rev, (maxSpeed), vex::velocityUnits::pct, false);
        //Intake.setTimeout(1000, vex::timeUnits::msec);

        vex::task::sleep(1000); 

        Intake.spin(vex::directionType::fwd, (0), vex::velocityUnits::pct);  


        startPid(0.5, 40, 0.5, 40);

        Intake.rotateFor(-2, vex::rotationUnits::rev, (maxSpeed * .80), vex::velocityUnits::pct, true);
        //turn left to face alliance platform
        currVal = avgGyro();
        FrontLeft.spin(vex::directionType::rev, 40, vex::velocityUnits::pct);
        BackLeft.spin(vex::directionType::rev, 40, vex::velocityUnits::pct);
        BackRight.spin(vex::directionType::fwd, 40, vex::velocityUnits::pct);
        FrontRight.spin(vex::directionType::fwd, 40, vex::velocityUnits::pct);

        //less turning with new strat -old: 890
        //while(((Gyro.value(vex::analogUnits::range12bit)) - currVal) > -825){
          // vex::task::sleep(10); 
       // }
        while(((avgGyro() - currVal) > -860)){
           vex::task::sleep(10); 
        }
        //stop motors with PID
        driveHold();
        driveTimeout(2, 2); 
        //stop motors and put them on coast
        vex::task::sleep(150);
        driveCoast();

        vex::task::sleep(300); 

        //prepull back puncher for shooting later on
        Puncher.rotateTo(180, vex::rotationUnits::deg, 100, vex::velocityUnits::pct, false);
        Puncher.setTimeout(600, vex::timeUnits::msec);

        //angle adjust ahead of time for first shot
        angleAdjust.rotateTo(30, vex::rotationUnits::deg, 100,vex::velocityUnits::pct, false);
        angleAdjust.setTimeout(600, vex::timeUnits::msec);

        //drive forward to align against low platform
        //startPid(5, 40, 5, 40);
        driveMoveFor(5, 40);

        vex::task::sleep(300); 

        //move right side backwards to slowly align with flags
        currVal = avgGyro();
        
        BackRight.spin(vex::directionType::rev, 25, vex::velocityUnits::pct);
        FrontRight.spin(vex::directionType::rev, 25, vex::velocityUnits::pct);

        //less turning with new strat -old: 890
        //while(((Gyro.value(vex::analogUnits::range12bit)) - currVal) > -825){
          // vex::task::sleep(10); 
       // }
        while(((avgGyro() - currVal) < 365)){
           vex::task::sleep(10); 
        }
        //stop motors with PID
        driveHold();
        driveTimeout(2, 2); 
        //stop motors and put them on coast
        vex::task::sleep(150);
        driveCoast();

        //aligned, so shoot both flags
        vex::task::sleep(3900); 
        //first shot would be too high, but we're already angle adjusted
        Puncher.rotateTo(360, vex::rotationUnits::deg, 100, vex::velocityUnits::pct, true);
        Puncher.setTimeout(1000, vex::timeUnits::msec);
        Puncher.stop(vex::brakeType::coast);

        //next ball up
        Intake.rotateFor(5, vex::rotationUnits::rev, (maxSpeed * .80), vex::velocityUnits::pct, false);
        vex::task::sleep(100);

        //angle adjust to medium height
        angleAdjust.rotateTo(130, vex::rotationUnits::deg,100,vex::velocityUnits::pct, true);
        angleAdjust.setTimeout(600, vex::timeUnits::msec);
        
        vex::task::sleep(100);

        //shoot next shot
        Puncher.rotateTo(720, vex::rotationUnits::deg, 100, vex::velocityUnits::pct, true);
        Puncher.setTimeout(1000, vex::timeUnits::msec);
        Puncher.stop(vex::brakeType::coast);
        vex::task::sleep(100);

        //reset angle-adjuster for start of match
        angleAdjust.rotateTo(0,vex::rotationUnits::deg,100,vex::velocityUnits::pct, false);
        angleAdjust.setTimeout(600, vex::timeUnits::msec);

        //stop intake (just in case)
        Intake.stop(vex::brakeType::coast);
        resetDrive();

        //move right side backwards to slowly align with flags
        currVal = avgGyro();
        
        BackRight.spin(vex::directionType::fwd, 40, vex::velocityUnits::pct);
        FrontRight.spin(vex::directionType::fwd, 40, vex::velocityUnits::pct);

        //less turning with new strat -old: 890
        //while(((Gyro.value(vex::analogUnits::range12bit)) - currVal) > -825){
          // vex::task::sleep(10); 
       // }
        while(((avgGyro() - currVal) > -365)){
           vex::task::sleep(10); 
        }
        //stop motors with PID
        driveHold();
        driveTimeout(2, 2); 
        //stop motors and put them on coast
        vex::task::sleep(150);
        driveCoast();

        //drive back a little before charging up platform
       // startPid(-11, 60, -11, 60);
        vex::task::sleep(300);

        Scrapper.rotateTo(-475, vex::rotationUnits::deg, 100, vex::velocityUnits::pct, true);
        Scrapper.setTimeout(750, vex::timeUnits::msec);
        //drive up platform
        startPid(27, 100, 27, 100);
        Scrapper.rotateTo(0, vex::rotationUnits::deg, 100, vex::velocityUnits::pct, true);
        Scrapper.setTimeout(750, vex::timeUnits::msec);
        */
    }

    void backBlueFar(){
        /*
        resetDrive();
        resetOthers();
        //start intake
        Intake.spin(vex::directionType::fwd, (maxSpeed * 0.8), vex::velocityUnits::pct);

        //run drive forward for 36 inches
        startPid(33.5, 55, 33.5, 55);
        //wait to intake ball
        vex::task::sleep(100); 

        //slow intake down so ball doesn't get yeet
        Intake.spin(vex::directionType::fwd, (maxSpeed * 0.2), vex::velocityUnits::pct);  

        resetDrive();

        //drive back a little
        startPid(-1, 40, -1, 40);

        //now that we have the ball, put it down a little before we shoot
        //Intake.rotateFor(-1.5, vex::rotationUnits::rev, (maxSpeed), vex::velocityUnits::pct, false);
        //Intake.setTimeout(1000, vex::timeUnits::msec);

        vex::task::sleep(250); 

        Intake.rotateFor(-1.5, vex::rotationUnits::rev, (maxSpeed * .80), vex::velocityUnits::pct, true);
        //turn left to face alliance platform
        currVal = avgGyro();
        FrontLeft.spin(vex::directionType::fwd, 40, vex::velocityUnits::pct);
        BackLeft.spin(vex::directionType::fwd, 40, vex::velocityUnits::pct);
        BackRight.spin(vex::directionType::rev, 40, vex::velocityUnits::pct);
        FrontRight.spin(vex::directionType::rev, 40, vex::velocityUnits::pct);

        //less turning with new strat -old: 890
        //while(((Gyro.value(vex::analogUnits::range12bit)) - currVal) > -825){
          // vex::task::sleep(10); 
       // }
        while(((avgGyro() - currVal) < 800)){
           vex::task::sleep(10); 
        }
        //stop motors with PID
        driveHold();
        driveTimeout(2, 2); 
        //stop motors and put them on coast
        vex::task::sleep(150);
        driveCoast();

        vex::task::sleep(300); 

        //prepull back puncher for shooting later on
        ///Puncher.rotateTo(180, vex::rotationUnits::deg, 100, vex::velocityUnits::pct, false);
        //Puncher.setTimeout(600, vex::timeUnits::msec);

        //angle adjust ahead of time for first shot
        angleAdjust.rotateTo(40, vex::rotationUnits::deg, 100,vex::velocityUnits::pct, false);
        angleAdjust.setTimeout(600, vex::timeUnits::msec);

        //drive forward to align against low platform
        //startPid(5, 40, 5, 40);
        driveMoveFor(5, 40);
        angleAdjust.stop(vex::brakeType::hold);

        vex::task::sleep(300); 

        //move right side backwards to slowly align with flags
        currVal = avgGyro();
        
        BackLeft.spin(vex::directionType::rev, 25, vex::velocityUnits::pct);
        FrontLeft.spin(vex::directionType::rev, 25, vex::velocityUnits::pct);

        //less turning with new strat -old: 890
        //while(((Gyro.value(vex::analogUnits::range12bit)) - currVal) > -825){
          // vex::task::sleep(10); 
       // }
        while(((avgGyro() - currVal) > -310)){
           vex::task::sleep(10); 
        }
        //stop motors with PID
        driveHold();
        driveTimeout(2, 2); 
        //stop motors and put them on coast
        vex::task::sleep(150);
        driveCoast();

        //aligned, so shoot both flags
        vex::task::sleep(4600); 
        //first shot would be too high, but we're already angle adjusted
        Puncher.rotateTo(360, vex::rotationUnits::deg, 100, vex::velocityUnits::pct, true);
        Puncher.setTimeout(1000, vex::timeUnits::msec);
        Puncher.stop(vex::brakeType::coast);

        //next ball up
        Intake.rotateFor(5, vex::rotationUnits::rev, (maxSpeed * .80), vex::velocityUnits::pct, false);
        vex::task::sleep(100);

        //angle adjust to medium height
        angleAdjust.rotateTo(115, vex::rotationUnits::deg,100,vex::velocityUnits::pct, true);
        angleAdjust.setTimeout(600, vex::timeUnits::msec);
        
        vex::task::sleep(100);

        //shoot next shot
        Puncher.rotateTo(720, vex::rotationUnits::deg, 100, vex::velocityUnits::pct, true);
        Puncher.setTimeout(1000, vex::timeUnits::msec);
        Puncher.stop(vex::brakeType::coast);
        vex::task::sleep(100);

        //reset angle-adjuster for start of match
        angleAdjust.rotateTo(0,vex::rotationUnits::deg,100,vex::velocityUnits::pct, false);
        angleAdjust.setTimeout(600, vex::timeUnits::msec);

        //stop intake (just in case)
        Intake.stop(vex::brakeType::coast);
        resetDrive();

        //move right side backwards to slowly align with flags
        currVal = avgGyro();
        
        BackLeft.spin(vex::directionType::fwd, 40, vex::velocityUnits::pct);
        FrontLeft.spin(vex::directionType::fwd, 40, vex::velocityUnits::pct);

        //less turning with new strat -old: 890
        //while(((Gyro.value(vex::analogUnits::range12bit)) - currVal) > -825){
          // vex::task::sleep(10); 
       // }
        while(((avgGyro() - currVal) < 310)){
           vex::task::sleep(10); 
        }
        //stop motors with PID
        driveHold();
        driveTimeout(2, 2); 
        //stop motors and put them on coast
        vex::task::sleep(150);
        driveCoast();

        //drive back a little before charging up platform
       // startPid(-11, 60, -11, 60);
        vex::task::sleep(300);

        Scrapper.rotateTo(-475, vex::rotationUnits::deg, 100, vex::velocityUnits::pct, true);
        Scrapper.setTimeout(750, vex::timeUnits::msec);
        //drive up platform
        startPid(27, 100, 27, 100);
        Scrapper.rotateTo(0, vex::rotationUnits::deg, 100, vex::velocityUnits::pct, true);
        Scrapper.setTimeout(750, vex::timeUnits::msec);
*/
    }
    

void autonomous( void ) {

    //start pid task for auto
    vex::task pidTasks(pidTask);
    vex::task turnTasks(turnTask);

    //red autos
    autoRunning = true;
    //backRedDouble();
    //threeFlagRed();
    //threeFlagBlue();
    //backBlueFar();
    //testingAuto();
     
    //how many "units"
    float tempVal = ((autoSelect.rotation(vex::rotationUnits::deg)) / 90);

    redSide = true;

    if(redSide){
        //use autoSelect to choose which auto to run
        if(tempVal < .25){
            //default - 5 flag
            Brain.Screen.printAt(1, 15, "5FlagRed");          
            threeFlagRed();
        }
        else if(tempVal < 1.25){
            //middle cross
            Brain.Screen.printAt(1, 15, "RedBackMiddle");  
            backRedMiddle();

        }
        else if(tempVal < 1.25 * 2){
            //descore far
            Brain.Screen.printAt(1, 15, "RedBackFar");  
            backRedFar();
            
            
        }
        /*
        else if(tempVal < 1.25 * 3){
            //descore far
            Brain.Screen.printAt(1, 15, "RedBackDouble");  
            backRedDouble();
        }
        */
    }   
    // B L U E  S I D E
    else if(!redSide){
        if(tempVal < .25){
            //default - 5 flag
            Brain.Screen.printAt(1, 15, "5FlagBlue");          
            threeFlagBlue();
        }
        else if(tempVal < 1.25){
            //middle cross
            Brain.Screen.printAt(1, 15, "BlueBackMiddle");  
            backBlueMiddle();

        }
        else if(tempVal < 1.25 * 2){
            //descore far
            Brain.Screen.printAt(1, 15, "BlueBackFar");  
            backBlueFar();
            
            
        }
        /*
        else if(tempVal < 1.25 * 3){
            //descore far
            Brain.Screen.printAt(1, 15, "BlueBackDouble");  
            backBlueDouble();
        }
        */
    }

    
    
    /*  all false = just 3 flag with cap flip
        if first bool true, 4 flag
        if second bool true, 5 flag
        if third bool true, parking auton
        (bool fourFlag, bool fiveFlag, bool park)
    */
    
    //3 flag function - red side
    //5 flag
      //threeFlagRed();
    //4 flag
      //threeFlagRed();
    //3 flag
      //threeFlagRed();

    //3 flag function - blue side
    //5 flag
      //threeFlagBlue();
    //4 flag
      //threeFlagBlue();
    //3 flag
      //threeFlagBlue();

    //back red park
    //redParking();

    //back blue park
    //blueParking();

        
    //back sides - red
    //backRedMiddle();
    //backRedFar();

    //back sides - blue
    //backBlueMiddle();
    //backBlueFar();

    //stop pid task - only needed for auto


    vex::task::stop(pidTask); 
    vex::task::stop(turnTask); 
    //wait 10 seconds
    vex::task::sleep(10000);

}


    void autoAngle(){
        //if puncher trigger is clicked
        //high flags
        if(angleTrigger){
            if(anglePos == 0){
                angleAdjust.rotateTo(0,vex::rotationUnits::deg,100,vex::velocityUnits::pct);
                angleAdjust.setTimeout(600, vex::timeUnits::msec);

                //angleAdjust.stop(vex::brakeType::coast);

            }
            //medium flag
            else if(anglePos == 1){
                angleAdjust.rotateTo(140,vex::rotationUnits::deg,100,vex::velocityUnits::pct);
                angleAdjust.setTimeout(600, vex::timeUnits::msec);


            }
            //lowest flag
            else if(anglePos == 2){
                 angleAdjust.rotateTo(262,vex::rotationUnits::deg,100,vex::velocityUnits::pct);
                 angleAdjust.setTimeout(600, vex::timeUnits::msec);



            }
            angleTrigger = false;
        }
    }
    
    void angleTriggerDetect(){
            //toggle between high and medium
            if(Controller1.ButtonUp.pressing()){
            //wait until released
               while(Controller1.ButtonUp.pressing()){
                   vex::task::sleep(100);
               }
            //run func
               if(anglePos != 2){
            angleTrigger = true;
            anglePos = 1 - anglePos;
        }
            }  

            //lowest flag toggle
            else if(Controller1.ButtonRight.pressing()){
                //wait until released
               while(Controller1.ButtonRight.pressing()){
                   vex::task::sleep(100);
               }
            //run func
            angleTrigger = true;

            anglePos = 2 - anglePos;
            }


            //motor holds
            if(!angleTrigger && !doubleShot){
            if(anglePos == 0)
                angleAdjust.stop(vex::brakeType::coast);
            
            //medium flag
            else if(anglePos == 1)
                angleAdjust.stop(vex::brakeType::hold);
            
            //lowest flag
            else if(anglePos == 2)
                 angleAdjust.stop(vex::brakeType::hold);
         }

        }
    

    

    void driveLockDetect(){
        if(Controller1.ButtonLeft.pressing()){
           //wait until released
           while(Controller1.ButtonLeft.pressing()){
               vex::task::sleep(100);
           }
           //run func
            driveLockOn = !driveLockOn;
           driveLock(driveLockOn);
       }
    }

  
    void scrapperMedium(){
        if(Controller1.ButtonY.pressing()){
            scrapperEnabled = true;
                //wait until released
                   while(Controller1.ButtonY.pressing()){
                       vex::task::sleep(100);
                   }

                //if scrapper is in (false)
                if(!scrapperPos){
                    Scrapper.rotateTo(-150, vex::rotationUnits::deg, 100, vex::velocityUnits::pct, true);
                    Scrapper.setTimeout(750, vex::timeUnits::msec);

                    scrapperRam = true;
                }
                //if scrapper is out (true)
                else if(scrapperPos){
                    Scrapper.rotateTo(0, vex::rotationUnits::deg, 100, vex::velocityUnits::pct, true);
                    Scrapper.setTimeout(750, vex::timeUnits::msec);

                    scrapperRam = false;
                }
                //switch pos cause it moved
                scrapperPos = !scrapperPos;
                //bool used to control motor hold for scrapper
                if(scrapperPos){
                    scrapperUp = true;
                }
                else if(!scrapperPos){
                    scrapperUp = false;
                }
                
                scrapperEnabled = false;
                }  
    }

    void scrapperRamMove(){
        if(Controller1.ButtonA.pressing()){
            scrapperEnabled = true;
                //wait until released
                   while(Controller1.ButtonA.pressing()){
                       vex::task::sleep(100);
                   }

                //if scrapper is in (false)
                if(!scrapperRam){
                    Scrapper.rotateTo(-280, vex::rotationUnits::deg, 100, vex::velocityUnits::pct, true);
                    Scrapper.setTimeout(750, vex::timeUnits::msec);

                    scrapperPos = true;
                }
                //if scrapper is out (true)
                else if(scrapperRam){
                    Scrapper.rotateTo(0, vex::rotationUnits::deg, 100, vex::velocityUnits::pct, true);
                    Scrapper.setTimeout(750, vex::timeUnits::msec);

                    scrapperPos = false;
                }
                //switch pos cause it moved
                scrapperRam = !scrapperRam;
                //bool used to control motor hold for scrapper
                if(scrapperRam){
                    scrapperUp = true;
                }
                else if(!scrapperRam){
                    scrapperUp = false;
                }
                
                scrapperEnabled = false;
                }  
    }


/*
     void moveWithShooting(){
        if(angleTrigger){
            scrapperEnabled = true;
            if(anglePos == 0){

                Scrapper.rotateTo(-200, vex::rotationUnits::deg, 100, vex::velocityUnits::pct, true);
                Scrapper.setTimeout(750, vex::timeUnits::msec);
                scrapperUp = true;

            }
            //medium flag
            else if(anglePos == 1){
                Scrapper.rotateTo(-250, vex::rotationUnits::deg, 100, vex::velocityUnits::pct, true);
                Scrapper.setTimeout(750, vex::timeUnits::msec);
                scrapperUp = true;
            }
            //lowest flag
            else if(anglePos == 2){
                Scrapper.rotateTo(-150, vex::rotationUnits::deg, 100, vex::velocityUnits::pct, true);
                Scrapper.setTimeout(750, vex::timeUnits::msec);
                scrapperUp = true;

            }
            scrapperEnabled = false;
        }
    }
*/

    void driveTaskFunc(){
        //the functions that run in this "othertask"
        
        //actions
        autoAngle();
       
        //puncher auto button
        angleTriggerDetect();
        
        //drive lock for platform
        driveLockDetect();
    }

void liftTaskFunc(){
        //the functions that run in this "othertask"
        
        //toggle
        scrapperMedium();

        scrapperRamMove();
        //moveWithShooting();
    }

    
int driveTask(){
        while(true){
            driveTaskFunc();
            //to not waste resources
            vex::task::sleep(20);
        }
        return 0;
    }

int liftTask(){
        while(true){
            liftTaskFunc();
            //to not waste resources
            vex::task::sleep(20);
        }
        return 0;
    }

    void controllerDisplay(){
            Controller1.Screen.clearScreen();


                    if(!driveLockOn){
                    Controller1.Screen.setCursor(3, 1);
                    //Controller1.Screen.print("               Off");
                    Controller1.Screen.print("Off");
                    }
                    else
                    {
                        Controller1.Screen.setCursor(3, 1);
                    Controller1.Screen.print("On");
                    }
        
                    Controller1.Screen.setCursor(1,1);
                    if(anglePos == 0){
                        Controller1.Screen.print("High");
                    }
                    else if(anglePos == 1){
                        Controller1.Screen.print("Medium");
                    }
                    else{
                        Controller1.Screen.print("Low");
                    }
                
                     
        }

    void brainDisplay(){
        Brain.Screen.clearScreen();
                //Brain.Screen.printAt(1, 115, "%d", vex::timer::system());

             // Brain.Screen.printAt(1, 120, "%d", test);
              //Brain.Screen.printAt(1, 15, "%d", Gyro.value(vex::analogUnits::pct));
              //Brain.Screen.printAt(1, 15, "%d", Gyro.value(vex::analogUnits::range8bit));
              //Brain.Screen.printAt(1, 50, "%.6f", Gyro.value(vex::analogUnits::range12bit));
              //Brain.Screen.printAt(1, 35, "%d", Gyro.value(vex::analogUnits::range12bit));
               Brain.Screen.printAt(1, 100, "%.6f", (gScale * Gyro2.value(vex::analogUnits::range12bit)));

              //Brain.Screen.printAt(1, 55, "%.6f", driveAvg());


             // Brain.Screen.printAt(1, 75, "%.6f", (gScale * Gyro2.value(vex::analogUnits::range12bit)));
               Brain.Screen.printAt(1, 135, "%.6f", (avgGyro()));  

               Brain.Screen.printAt(1, 160, "%.6f", autoSelect.rotation(vex::rotationUnits::deg));
              //Brain.Screen.printAt(1, 155, "%.6f", (   (Gyro.value(vex::analogUnits::range12bit) + (gScale * Gyro2.value(vex::analogUnits::range12bit)))  / 2  ));
              //Brain.Screen.printAt(1, 115, "%.6f", FrontLeft.rotation(vex::rotationUnits::deg));
              //Brain.Screen.printAt(1, 135, "%.6f", BackLeft.rotation(vex::rotationUnits::deg));
              //Brain.Screen.printAt(1, 155, "%.6f", FrontRight.rotation(vex::rotationUnits::deg));
              //Brain.Screen.printAt(1, 175, "%.6f", BackRight.rotation(vex::rotationUnits::deg));
         
              //Brain.Screen.printAt(1, 195, "5FlagRed");          
    }



    //task only used to update brain and controller displays
    //also used to select auton's
    int displayTask(){
        while(true){
            controllerDisplay();
            brainDisplay();
            //to not waste resources - 150 cause display doesn't need to be updated super fast
            vex::task::sleep(150);
        }
        return 0;
    }

    
    void driveTrainControl(void){
            moveLeft(Controller1.Axis3.value());
            moveRight(Controller1.Axis2.value());
    }

    //intake control for roller
    //if drivetype is true, run shooting mode
    void IntakeControl(void){

        if(!doubleShot){
            if(Controller1.ButtonL2.pressing()){
                Intake.spin(vex::directionType::fwd, (maxSpeed * 1), vex::velocityUnits::pct);
            }
            else if(Controller1.ButtonL1.pressing()){
                Intake.spin(vex::directionType::rev, (maxSpeed * 1), vex::velocityUnits::pct);
            }
            else {
                Intake.stop(vex::brakeType::coast);
            }
        }
    }
        
    void scrapperControl(void){ 
        if(!scrapperEnabled){
        if(Controller1.ButtonX.pressing()){
            //if button is pressed, turn lock off
            scrapperUp = false;
                Scrapper.spin(vex::directionType::fwd, maxSpeed * 1, vex::velocityUnits::pct);
            }
        else if(Controller1.ButtonB.pressing()){
            //if button is pressed, turn lock off
            scrapperUp = false;
                    Scrapper.spin(vex::directionType::rev, maxSpeed * 1, vex::velocityUnits::pct);
            }
            else {
                if(scrapperUp)
                    Scrapper.stop(vex::brakeType::hold);
                else
                    Scrapper.stop(vex::brakeType::coast);
            }

            }
    }
        
    void allRemoteFunc(void){
        scrapperControl();
        //PuncherControl();
        IntakeControl();
        driveTrainControl();      
    }

void usercontrol( void ) {
    autoRunning = false;
  // User control code here, inside the loop
    
  //initiate task for triggers, like cap control and puncher button
  //vex::task stop(autoTask); 
  vex::task driveTriggers(driveTask);
  vex::task ratchetTriggers(ratchetTask);
  vex::task liftTriggers(liftTask);
  int pLastVal = 0;
  
  //initiate task for brain and controller displays
  vex::task display(displayTask);

        Puncher.stop(vex::brakeType::coast);
        Intake.stop(vex::brakeType::coast);
        Puncher.resetRotation();
        driveCoast();
        resetDrive();

vex::task::stop(pidTask); 
vex::task::stop(turnTask);
  while (true) {
    allRemoteFunc();  
    vex::task::sleep(20); //Sleep the task for a short amount of time to prevent wasted resources. 
  }
}

int main() {

    
    //Run the pre-autonomous function. 
    pre_auton();
    
    //Set up callbacks for autonomous and driver control periods.
    Competition.autonomous(autonomous);
    Competition.drivercontrol(usercontrol);

    //Prevent main from exiting with an infinite loop.                        
    while(true) {
      vex::task::sleep(100);//Sleep the task for a short amount of time to prevent wasted resources.
    }    
       
}   