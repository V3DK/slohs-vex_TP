#include "robot-config.h"

//Creates a competition object that allows access to Competition methods.
vex::competition    Competition;

/*--------------------------------------------------------------------------
Both:
Joysticks - Tank Control
A - Switch Drive Modes [Initially in Flags]


Displays Drive Mode on Controller

Flags: 
Joystick - Intake Side as Forward
R2 - Puncher Trigger [Once pressed, runs task to shoot puncher]
R1 - Manual Puncher Control [Forward]
L2 - Intake In
L1 - Intake Out

Caps:
Joystick - Cap Intake Side as Forward
R2 - Lift Down
R1 - Lift Up
L2 - Cap Intake Down [Manual]
L1 - Cap Intake Up [Manual]
Up - Cap Intake Trigger [Once pressed, runs task to flip cap]
Down - 




--------------------------------------------------------------------------*/
int maxSpeed = 100;

//int test = 0;


/* Drive Type: Var for what the controller is controlling
true (initial) - Flags
false - Caps
*/

float math_Pi = 3.1415926535897932384626433;

//vars for trigger control
bool driveType = true;
bool puncherTrigger = false;
bool capTrigger = false;
bool driveLockOn = false;
bool liftReset = false;
/*---------------------------------------------------------------------------*/
/*                          Pre-Autonomous Functions                         */
/*                                                                           */
/*  You may want to perform some actions before the competition starts.      */
/*  Do them in the following function.  You must return from this function   */
/*  or the autonomous and usercontrol tasks will not be started.  This       */
/*  function is only called once after the cortex has been powered on and    */ 
/*  not every time that the robot is disabled.                               */
/*---------------------------------------------------------------------------*/

void pre_auton( void ) {
  // All activities that occur before the competition starts
  // Example: clearing encoders, setting servo positions, ...
    
    //calibrate gyro
    Gyro.startCalibration();
        //wait until done calibrating
    while(Gyro.isCalibrating()){
        vex::task::sleep(100);
    }
    vex::task::sleep(1000);

    
}
    
    void driveLock(bool z){
        // if z is true, lock is turned on
        // else, it's turned off
        
        if(z){
            FrontLeft.stop(vex::brakeType::hold);
            BackLeft.stop(vex::brakeType::hold);
            FrontRight.stop(vex::brakeType::hold);
            BackRight.stop(vex::brakeType::hold);  
        }
        else if(!z) {
            FrontLeft.stop(vex::brakeType::coast);
            BackLeft.stop(vex::brakeType::coast);
            FrontRight.stop(vex::brakeType::coast);
            BackRight.stop(vex::brakeType::coast);
        }

    }

    void resetDrive(){
        FrontLeft.resetRotation();
        BackLeft.resetRotation();
        FrontRight.resetRotation();
        BackRight.resetRotation();
    }
    //d in inches
    //s speed - in pct out of %100
    void driveMoveFor(float d, int s){
        resetDrive();
        driveLock(false);
        float revo = d / (4 * math_Pi);
        FrontLeft.rotateFor(revo, vex::rotationUnits::rev, s, vex::velocityUnits::pct, false);
        BackLeft.rotateFor(revo, vex::rotationUnits::rev, s, vex::velocityUnits::pct, false);
        FrontRight.rotateFor(revo, vex::rotationUnits::rev, s, vex::velocityUnits::pct, false);
        BackRight.rotateFor(revo, vex::rotationUnits::rev, s, vex::velocityUnits::pct, true);
        //driveLock(true);
    }
    
    //left dist in inches - negative for backwards
    //right dist in inches
    //left speed in pct
    //right speed in pct
    void driveTurnFor(float leftdist, float rightddist, int leftSpeed, int rightSpeed){
        resetDrive();
        driveLock(true);
        float Lrevo = leftdist / (4 * math_Pi);
        float Rrevo = rightddist / (4 * math_Pi);
        FrontLeft.rotateFor(Lrevo, vex::rotationUnits::rev, leftSpeed, vex::velocityUnits::pct, false);
        BackLeft.rotateFor(Lrevo, vex::rotationUnits::rev, leftSpeed, vex::velocityUnits::pct, false);
        FrontRight.rotateFor(Rrevo, vex::rotationUnits::rev, rightSpeed, vex::velocityUnits::pct, false);
        BackRight.rotateFor(Rrevo, vex::rotationUnits::rev, rightSpeed, vex::velocityUnits::pct, true);
        driveLock(true);
    }

    void driveTimeout(float leftTime, float rightTime){
        FrontLeft.setTimeout(leftTime, vex::timeUnits::sec);
        BackLeft.setTimeout(leftTime, vex::timeUnits::sec);
        FrontRight.setTimeout(rightTime, vex::timeUnits::sec);
        BackRight.setTimeout(rightTime, vex::timeUnits::sec);
    }

    void flag3Red(){
        resetDrive();
        //start intake
        Intake.spin(vex::directionType::fwd, (maxSpeed * .20), vex::velocityUnits::pct);
        
        //run drive forward for 34 inches
        driveMoveFor(36.5, 75);
        driveTimeout(3, 3);
        //delay and wait for .7 of a second
        vex::task::sleep(350);
        //stop intake
        Intake.stop(vex::brakeType::coast); 
        //vex::task::sleep(200);
        
        //drive back 36 inches
        //driveMoveFor(-36, 75);
        driveMoveFor(-46, 75);
        driveTimeout(3, 3);
        //run with timing to realign against field wall
        resetDrive();
        //vex::task::sleep(200);
        //drive forward 5 inches for flag alignment before turning
        driveMoveFor(10, 35);
        driveTimeout(1, 1);
        //vex::task::sleep(200);
        //driveTurnFor(-10.5, 10.5, 30, 30);
        FrontLeft.spin(vex::directionType::rev, 50, vex::velocityUnits::pct);
        BackLeft.spin(vex::directionType::rev, 50, vex::velocityUnits::pct);
        BackRight.spin(vex::directionType::fwd, 50, vex::velocityUnits::pct);
        FrontRight.spin(vex::directionType::fwd, 50, vex::velocityUnits::pct);
        int curr = Gyro.value(vex::analogUnits::range8bit);
        while(((Gyro.value(vex::analogUnits::range8bit)) - curr) > -51){
           vex::task::sleep(10); 
        }
        FrontLeft.stop(vex::brakeType::hold);
        BackLeft.stop(vex::brakeType::hold);
        BackRight.stop(vex::brakeType::hold);
        FrontRight.stop(vex::brakeType::hold);
        driveTimeout(1, 1);
        
        Puncher.rotateFor(360, vex::rotationUnits::deg,100,vex::velocityUnits::pct, false);
        Puncher.setTimeout(1, vex::timeUnits::sec);
        
        vex::task::sleep(250);
        FrontLeft.stop(vex::brakeType::coast);
        BackLeft.stop(vex::brakeType::coast);
        BackRight.stop(vex::brakeType::coast);
        FrontRight.stop(vex::brakeType::coast);

        driveMoveFor(2, 50);
        driveTimeout(1, 1);
        vex::task::sleep(100);
        Intake.rotateFor(3, vex::rotationUnits::rev, (maxSpeed * .66), vex::velocityUnits::pct, false);
        driveMoveFor(21, 65);
        //second shot
        Puncher.rotateFor(360, vex::rotationUnits::deg,100,vex::velocityUnits::pct);
        driveTimeout(1.5, 1.5);
        vex::task::sleep(100);
        Intake.spin(vex::directionType::fwd, (maxSpeed * .75), vex::velocityUnits::pct);
        
        //vex::task::sleep(2000);
        //turn for low flags
        curr = Gyro.value(vex::analogUnits::range8bit);
        FrontLeft.spin(vex::directionType::rev, 30, vex::velocityUnits::pct);
        BackLeft.spin(vex::directionType::rev, 30, vex::velocityUnits::pct);
        BackRight.spin(vex::directionType::fwd, 30, vex::velocityUnits::pct);
        FrontRight.spin(vex::directionType::fwd, 30, vex::velocityUnits::pct);
        
        while(((Gyro.value(vex::analogUnits::range8bit)) - curr) > -7){
        } 
        
        FrontLeft.stop(vex::brakeType::hold);
        BackLeft.stop(vex::brakeType::hold);
        BackRight.stop(vex::brakeType::hold);
        FrontRight.stop(vex::brakeType::hold);
        driveTimeout(1, 1);    
        vex::task::sleep(250);
        FrontLeft.stop(vex::brakeType::coast);
        BackLeft.stop(vex::brakeType::coast);
        BackRight.stop(vex::brakeType::coast);
        FrontRight.stop(vex::brakeType::coast);
        
        driveMoveFor(5, 50);
        FrontLeft.spin(vex::directionType::fwd, 50, vex::velocityUnits::pct);
        BackLeft.spin(vex::directionType::fwd, 50, vex::velocityUnits::pct);
        BackRight.spin(vex::directionType::rev, 50, vex::velocityUnits::pct);
        FrontRight.spin(vex::directionType::rev, 50, vex::velocityUnits::pct);
        curr = Gyro.value(vex::analogUnits::range8bit);
        
        while(((Gyro.value(vex::analogUnits::range8bit)) - curr) < 7){
        }
        
        FrontLeft.stop(vex::brakeType::hold);
        BackLeft.stop(vex::brakeType::hold);
        BackRight.stop(vex::brakeType::hold);
        FrontRight.stop(vex::brakeType::hold);
        driveTimeout(1, 1);    
        vex::task::sleep(250);
        FrontLeft.stop(vex::brakeType::coast);
        BackLeft.stop(vex::brakeType::coast);
        BackRight.stop(vex::brakeType::coast);
        FrontRight.stop(vex::brakeType::coast);
        driveMoveFor(23, 75);
        vex::task::sleep(100);
        driveMoveFor(-19, 75);
        CapIntake.rotateTo(0,vex::rotationUnits::deg, 80,vex::velocityUnits::pct, false);
        Lift.rotateTo(0, vex::rotationUnits::deg, 85,vex::velocityUnits::pct);
            
        
        //Puncher.rotateFor(150, vex::rotationUnits::deg, 100, vex::velocityUnits::pct, false);

        FrontLeft.spin(vex::directionType::fwd, 50, vex::velocityUnits::pct);
        BackLeft.spin(vex::directionType::fwd, 50, vex::velocityUnits::pct);
        BackRight.spin(vex::directionType::rev, 50, vex::velocityUnits::pct);
        FrontRight.spin(vex::directionType::rev, 50, vex::velocityUnits::pct);
 
        curr = Gyro.value(vex::analogUnits::range8bit);
        while(((Gyro.value(vex::analogUnits::range8bit)) - curr) < 62){
           vex::task::sleep(10); 
        }
        FrontLeft.stop(vex::brakeType::hold);
        BackLeft.stop(vex::brakeType::hold);
        BackRight.stop(vex::brakeType::hold);
        FrontRight.stop(vex::brakeType::hold);
        Puncher.stop(vex::brakeType::hold);
        driveTimeout(1, 1);
        vex::task::sleep(100);
        FrontLeft.stop(vex::brakeType::coast);
        BackLeft.stop(vex::brakeType::coast);
        BackRight.stop(vex::brakeType::coast);
        FrontRight.stop(vex::brakeType::coast);
        Intake.spin(vex::directionType::rev, (maxSpeed * .50), vex::velocityUnits::pct);
        
        driveMoveFor(52, 70);
        
        Puncher.rotateFor(150, vex::rotationUnits::deg, 100, vex::velocityUnits::pct, false);
        FrontLeft.spin(vex::directionType::rev, 50, vex::velocityUnits::pct);
        BackLeft.spin(vex::directionType::rev, 50, vex::velocityUnits::pct);
        BackRight.spin(vex::directionType::fwd, 50, vex::velocityUnits::pct);
        FrontRight.spin(vex::directionType::fwd, 50, vex::velocityUnits::pct);
        curr = Gyro.value(vex::analogUnits::range8bit);
        
        while(((Gyro.value(vex::analogUnits::range8bit)) - curr) > -33){
           vex::task::sleep(10); 
        }
        
        FrontLeft.stop(vex::brakeType::hold);
        BackLeft.stop(vex::brakeType::hold);
        BackRight.stop(vex::brakeType::hold);
        FrontRight.stop(vex::brakeType::hold);
        driveTimeout(1, 1);
        Puncher.rotateFor(360, vex::rotationUnits::deg, 100,vex::velocityUnits::pct, false);
        Puncher.setTimeout(1, vex::timeUnits::sec);
        vex::task::sleep(250);
        FrontLeft.stop(vex::brakeType::coast);
        BackLeft.stop(vex::brakeType::coast);
        BackRight.stop(vex::brakeType::coast);
        FrontRight.stop(vex::brakeType::coast);
        
        driveTurnFor(31, 31, 60, 100);
        Puncher.stop(vex::brakeType::coast);
    }

void autonomous( void ) {
    flag3Red();
    driveLock(false);
    vex::task::sleep(15000);
}

    void autoPuncher(){
        //if in flag mode and puncher trigger is clicked
        if(driveType && puncherTrigger){
            Puncher.rotateFor(360,vex::rotationUnits::deg,100,vex::velocityUnits::pct);
            Puncher.setTimeout(800, vex::timeUnits::msec);
            puncherTrigger = false;
        }
    }
    
    void puncherTriggerDetect(){
        if(driveType){
            if(Controller1.ButtonX.pressing()){
            //wait until released
               while(Controller1.ButtonX.pressing()){
                   vex::task::sleep(100);
               }
            //run func
            puncherTrigger = true;
            }  
        }
    }

    void autoCapFlip(){
        //if in cap mode and cap trigger is clicked
        if(!driveType && capTrigger){
            CapIntake.rotateTo(-60,vex::rotationUnits::deg, 60,vex::velocityUnits::pct);
            vex::task::sleep(350);
            CapIntake.rotateTo(-315,vex::rotationUnits::deg, 55,vex::velocityUnits::pct);
            CapIntake.setTimeout(2000, vex::timeUnits::msec);
            capTrigger = false;
        }
    }

      void capTriggerDetect(){
            if(!driveType){
                
                //button for main cap flip
                if(Controller1.ButtonUp.pressing()){
                //wait until released
                   while(Controller1.ButtonUp.pressing()){
                       vex::task::sleep(100);
                   }
                //run func
                capTrigger = true;
                }  
            }
        }
    void driveSwitch(){
        //if button A is pressed
       if(Controller1.ButtonA.pressing()){
           //wait until released
           while(Controller1.ButtonA.pressing()){
               vex::task::sleep(100);
           }
           //run func
           driveType = !driveType;
          
       }
        
    }


    

    void driveLockDetect(){
        if(Controller1.ButtonB.pressing()){
           //wait until released
           while(Controller1.ButtonB.pressing()){
               vex::task::sleep(100);
           }
           //run func
            driveLockOn = !driveLockOn;
           driveLock(driveLockOn);
       }
    }
    
    void autoLiftReset(){
        if(liftReset){
        CapIntake.rotateTo(0,vex::rotationUnits::deg, 80,vex::velocityUnits::pct, false);
        Lift.rotateTo(0, vex::rotationUnits::deg, 85,vex::velocityUnits::pct);
            liftReset = false;
        }
    }

    void liftResetDetect(){
        
                
                //button for main cap flip
                if(Controller1.ButtonDown.pressing()){
                //wait until released
                   while(Controller1.ButtonDown.pressing()){
                       vex::task::sleep(100);
                   }
                //run func
                liftReset = true;
                }  
    }


    void otherTaskFunc(){
        //the functions that run in this "othertask"
        
        //actions
        autoPuncher();
        autoCapFlip();
        autoLiftReset();
        
        //detections
        //switch drive into cap mode
        driveSwitch();
        liftResetDetect();
        
        
        //auto flip for cap
        capTriggerDetect();
        
        //puncher auto button
        puncherTriggerDetect();
        
        //drive lock for platform
        driveLockDetect();
    }
//other task used to run puncher and cap intake triggers
    int otherTask(){
        while(true){
            otherTaskFunc();
            //to not waste resources
            vex::task::sleep(20);
        }
        return 0;
    }


    void controllerDisplay(){
            Controller1.Screen.clearScreen();
                if(driveType){
                    Controller1.Screen.setCursor(1,1);
                    Controller1.Screen.print("Flags");
                }
                else if(!driveType){
                    Controller1.Screen.setCursor(1,17);
                    //Controller1.Screen.print("              Caps");
                    Controller1.Screen.print("Caps");
                }
        
                if(driveLockOn){
                    Controller1.Screen.setCursor(20,1);
                    Controller1.Screen.print("On");
                }
                else if(!driveLockOn){
                    Controller1.Screen.setCursor(20, 18);
                    //Controller1.Screen.print("               Off");
                    Controller1.Screen.print("Off");
                }
        }

    void brainDisplay(){
        Brain.Screen.clearScreen();
            //Brain.Screen.printAt(1, 40, "%d", capTrigger);
            //Brain.Screen.printAt(1, 120, "%d", capResetTrigger);
            //Brain.Screen.printAt(1, 80, "%d", puncherTrigger);
            //Brain.Screen.printAt(1, 120, "%d", test);
            Brain.Screen.printAt(1, 15, "%d", Gyro.value(vex::analogUnits::pct));
              Brain.Screen.printAt(1, 35, "%d", Gyro.value(vex::analogUnits::range8bit));
              Brain.Screen.printAt(1, 55, "%d", Gyro.value(vex::analogUnits::range10bit));
              Brain.Screen.printAt(1, 55, "%d", Gyro.value(vex::analogUnits::range12bit));
              Brain.Screen.printAt(1, 75, "%d", Gyro.value(vex::analogUnits::mV));
            
              //Brain.Screen.printAt(1, 115, "%d", Gyro.value(vex::rotationUnits::deg));
            
              Brain.Screen.printAt(1, 155, "%d", Gyro.value(vex::percentUnits::pct));
              Brain.Screen.printAt(1, 180, "%d", liftReset);
    }



    //task only used to update brain and controller displays
    int displayTask(){
        while(true){
            controllerDisplay();
            brainDisplay();
            //to not waste resources - 150 cause display doesn't need to be updated super fast
            vex::task::sleep(150);
        }
        return 0;
    }

    
    void driveTrainControl(void){
        
        //lock drive if joysticks not moved
      /*  if((abs(Controller1.Axis2.value()) < 15) && (abs(Controller1.Axis3.value()) < 15)) {
            driveLock(true);     
        }
        */
        //else
        if(driveType){
            FrontLeft.spin(vex::directionType::fwd, Controller1.Axis3.value(), vex::velocityUnits::pct);
            BackLeft.spin(vex::directionType::fwd, Controller1.Axis3.value(), vex::velocityUnits::pct);
            FrontRight.spin(vex::directionType::fwd, Controller1.Axis2.value(), vex::velocityUnits::pct);
            BackRight.spin(vex::directionType::fwd, Controller1.Axis2.value(), vex::velocityUnits::pct);
            
        }
        else {
            FrontLeft.spin(vex::directionType::rev, Controller1.Axis2.value(), vex::velocityUnits::pct);
            BackLeft.spin(vex::directionType::rev, Controller1.Axis2.value(), vex::velocityUnits::pct);
            FrontRight.spin(vex::directionType::rev, Controller1.Axis3.value(), vex::velocityUnits::pct);
            BackRight.spin(vex::directionType::rev, Controller1.Axis3.value(), vex::velocityUnits::pct);
        }
    }

    //intake control for roller
    //if drivetype is true, run shooting mode
    void IntakeControl(void){
        if(driveType){
            if(Controller1.ButtonL2.pressing()){
                Intake.spin(vex::directionType::fwd, (maxSpeed * .66), vex::velocityUnits::pct);
            }
            else if(Controller1.ButtonL1.pressing()){
                Intake.spin(vex::directionType::rev, (maxSpeed * .66), vex::velocityUnits::pct);
            }
            else {
                Intake.stop(vex::brakeType::coast);
            }
        }
    }
    
    void PuncherControl(void){
    //button  
        if(driveType){
        
            if(!puncherTrigger){
                /*
                if(Controller1.ButtonR1.pressing()){
                    Puncher.spin(vex::directionType::rev, maxSpeed / 1.5, vex::velocityUnits::pct);
                }
                
                else */if(Controller1.ButtonR2.pressing()){
                    Puncher.spin(vex::directionType::fwd, maxSpeed, vex::velocityUnits::pct);
                }
                
                else {
                    Puncher.stop(vex::brakeType::coast);
                    //Puncher.stop(vex::brakeType::brake);
                }
                
                
            }
        }
    }
    void LiftControl(void){
    //preset heights
        if(!driveType){
            if(Controller1.ButtonR1.pressing()){
                Lift.spin(vex::directionType::fwd, maxSpeed, vex::velocityUnits::pct);
            }
            else if(Controller1.ButtonR2.pressing()){
                Lift.spin(vex::directionType::rev, maxSpeed, vex::velocityUnits::pct);
            }
            else if(!liftReset){
                //Lift.stop(vex::brakeType::brake);
                Lift.stop(vex::brakeType::coast);
            }

        }
    
    }
    void CapIntakeControl(void){
    //button
       
        if(!driveType){
             
            if(Controller1.ButtonL1.pressing()){
                CapIntake.spin(vex::directionType::fwd, maxSpeed / 2, vex::velocityUnits::pct);
            }
            else if(Controller1.ButtonL2.pressing()){
                CapIntake.spin(vex::directionType::rev, maxSpeed / 2, vex::velocityUnits::pct);
            }
            else if((!capTrigger) && (!liftReset)){
                //CapIntake.spin(vex::directionType::fwd, 0, vex::velocityUnits::pct);
                CapIntake.stop(vex::brakeType::coast);
             
            } 
            /*
            //button for main cap flip
            if(Controller1.ButtonUp.pressing()){
            //wait until released
               while(Controller1.ButtonUp.pressing()){
                   vex::task::sleep(100);
               }
            //run func
            capTrigger = true;
            }
            */
        }
    }


    void allRemoteFunc(void){
        CapIntakeControl();
        LiftControl();
        PuncherControl();
        IntakeControl();
        driveTrainControl();      
    }

void usercontrol( void ) {
  // User control code here, inside the loop
    
  //initiate task for triggers, like cap control and puncher button
  vex::task trigger(otherTask, 1);
  
  //initiate task for brain and controller displays
  vex::task display(displayTask, 2);
    
  while (1) {
      allRemoteFunc();                
    vex::task::sleep(20); //Sleep the task for a short amount of time to prevent wasted resources. 
  }
}


int main() {
    
    //Run the pre-autonomous function. 
    pre_auton();
    
    //Set up callbacks for autonomous and driver control periods.
    Competition.autonomous(autonomous);
    Competition.drivercontrol(usercontrol);

    //Prevent main from exiting with an infinite loop.                        
    while(true) {
      vex::task::sleep(100);//Sleep the task for a short amount of time to prevent wasted resources.
    }    
       
}