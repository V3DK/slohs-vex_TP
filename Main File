 #include "robot-config.h"

//Creates a competition object that allows access to Competition methods.
vex::competition    Competition;

/*--------------------------------------------------------------------------
Both:
Joysticks - Tank Control
A - Switch Drive Modes [Initially in Flags]


Displays Drive Mode on Controller

Flags: 
Joystick - Intake Side as Forward
R2 - Puncher Trigger [Once pressed, runs task to shoot puncher]
R1 - Manual Puncher Control [Forward]
L2 - Intake In
L1 - Intake Out

Caps:
Joystick - Cap Intake Side as Forward
R2 - Lift Down
R1 - Lift Up
L2 - Cap Intake Down [Manual]
L1 - Cap Intake Up [Manual]
Up - Cap Intake Trigger [Once pressed, runs task to flip cap]
Down - 




--------------------------------------------------------------------------*/
int maxSpeed = 100;
int trevo = 0;
int joyVal = 0;
//int test = 0;


/* Drive Type: Var for what the controller is controlling
true (initial) - Flags
false - Caps
*/

//used to calculate driving distances in auton
float math_Pi = 3.1415926535897932384626433;

//vars for trigger control
//not used anymore
//bool driveType = true;

//bool liftActivate = false;

/*
if 0 - down (high flag)
if 1 - middle (medium flag)
if 2 - up (low flag)
*/
int anglePos = 0;
bool angleTrigger = false;
//bool capTrigger = false;
bool driveLockOn = false;
bool liftReset = false;
bool liftMedium = false;
bool liftOn = false;

//var to determine whether to use joystick or buttons for cap intake
//bool capJoy = true;

bool puncherIsMoving = false;

//activate bool

//used to tell auton helper task to pull back puncher
bool prePuncher = false;
int puncherPreValue = 150;

//current gyro val holding var
int currVal = 0;

void resetDrive(){
        FrontLeft.resetRotation();
        BackLeft.resetRotation();
        FrontRight.resetRotation();
        BackRight.resetRotation();
    }
/*---------------------------------------------------------------------------*/
/*                          Pre-Autonomous Functions                         */
/*                                                                           */
/*  You may want to perform some actions before the competition starts.      */
/*  Do them in the following function.  You must return from this function   */
/*  or the autonomous and usercontrol tasks will not be started.  This       */
/*  function is only called once after the cortex has been powered on and    */ 
/*  not every time that the robot is disabled.                               */
/*---------------------------------------------------------------------------*/

void pre_auton( void ) {
  // All activities that occur before the competition starts
  // Example: clearing encoders, setting servo positions, ...
    
    //resetDrive encoders
    resetDrive();
    //calibrate gyro
    Gyro.startCalibration();
        //wait until done calibrating
    while(Gyro.isCalibrating()){
        Brain.Screen.printAt(1, 40, "Calibrating Gyro . . .");
        vex::task::sleep(100);
    }
    
    //just to make sure gyro is calibrated
    vex::task::sleep(1000);
    Brain.Screen.clearScreen();
    Brain.Screen.printAt(1, 40, "Gyro Calibrated!");
 
}

//helper task for autonomous
//used for pulling back puncher before it shoots
int autoTask(){
        while(true){
            //wait until puncher preshoot is turned on
            if(prePuncher){
              //pull puncher back puncherPreValue degrees
              Puncher.rotateFor(puncherPreValue, vex::rotationUnits::deg, 100,vex::velocityUnits::pct, true);
              Puncher.stop(vex::brakeType::hold);

              //reset preVal to default
              puncherPreValue = 150;

              //disable
              prePuncher = false;
            }

            //to not waste resources
            vex::task::sleep(20);
        }
        return 0;
    }

    void driveCoast(){
      FrontLeft.stop(vex::brakeType::coast);
      BackLeft.stop(vex::brakeType::coast);
      BackRight.stop(vex::brakeType::coast);
      FrontRight.stop(vex::brakeType::coast);

    }
    void driveHold(){
      FrontLeft.stop(vex::brakeType::hold);
      BackLeft.stop(vex::brakeType::hold);
      BackRight.stop(vex::brakeType::hold);
      FrontRight.stop(vex::brakeType::hold);
    }


    //gyro turn func
    //bool rightTurn - is it a right turn or not
    //vLeft - velocity of left side of drive
    //vRight - velocity of right side of drive
    //amt - amount to turn

    void gyroTurn(bool rightTurn, int vLeft, int vRight, int amt){
        
        //steal the gyro's current value
        currVal = Gyro.value(vex::analogUnits::range8bit);
        
        //if it's a right turn, execute right turn procedure
        if(rightTurn){
          FrontLeft.spin(vex::directionType::fwd, vLeft, vex::velocityUnits::pct);
          BackLeft.spin(vex::directionType::fwd, vLeft, vex::velocityUnits::pct);
          BackRight.spin(vex::directionType::rev, vRight, vex::velocityUnits::pct);
          FrontRight.spin(vex::directionType::rev, vRight, vex::velocityUnits::pct);
          //wait until difference between real time value and stored value passes threshold
          while(((Gyro.value(vex::analogUnits::range8bit)) - currVal) < amt){
            vex::task::sleep(10); 
          }
          driveHold();
          vex::task::sleep(250);
          driveCoast();
        }
        //if it's a left turn, execute left turn
        else if(!rightTurn){
          FrontLeft.spin(vex::directionType::rev, vLeft, vex::velocityUnits::pct);
          BackLeft.spin(vex::directionType::rev, vLeft, vex::velocityUnits::pct);
          BackRight.spin(vex::directionType::fwd, vRight, vex::velocityUnits::pct);
          FrontRight.spin(vex::directionType::fwd, vRight, vex::velocityUnits::pct);
          while(((Gyro.value(vex::analogUnits::range8bit)) - currVal) > (-1 * amt)){
            vex::task::sleep(10); 
          }
          driveHold();
          vex::task::sleep(250);
          driveCoast();
        }
      }
    
    //function to toggle lock and coast with boolean
    void driveLock(bool z){
        // if z is true, lock is turned on
        // else, it's turned off
        if(z){
            driveHold(); 
        }
        else if(!z) {
            driveCoast();
        }
    }

    //d in inches
    //s speed - in pct out of %100
    void driveMoveFor(float d, int s){
        resetDrive();
        driveLock(false);
        //calculate distance from inches to revolutions
        float revo = d / (4 * math_Pi);
        FrontLeft.rotateFor(revo, vex::rotationUnits::rev, s, vex::velocityUnits::pct, false);
        FrontRight.rotateFor(revo, vex::rotationUnits::rev, s, vex::velocityUnits::pct, false);
        BackLeft.rotateFor(revo, vex::rotationUnits::rev, s, vex::velocityUnits::pct, false);
        BackRight.rotateFor(revo, vex::rotationUnits::rev, s, vex::velocityUnits::pct, true);
        //driveLock(true);
    }
    
  //turning without gyro
    //left dist in inches - negative for backwards
    //right dist in inches
    //left speed in pct
    //right speed in pct
    void driveTurnFor(float leftdist, float rightddist, int leftSpeed, int rightSpeed){
        resetDrive();
        driveLock(true);
        float Lrevo = leftdist / (4 * math_Pi);
        float Rrevo = rightddist / (4 * math_Pi);
        FrontLeft.rotateFor(Lrevo, vex::rotationUnits::rev, leftSpeed, vex::velocityUnits::pct, false);
        BackLeft.rotateFor(Lrevo, vex::rotationUnits::rev, leftSpeed, vex::velocityUnits::pct, false);
        FrontRight.rotateFor(Rrevo, vex::rotationUnits::rev, rightSpeed, vex::velocityUnits::pct, false);
        BackRight.rotateFor(Rrevo, vex::rotationUnits::rev, rightSpeed, vex::velocityUnits::pct, true);
        driveLock(true);
    }
/*
    double avgDrive(){
        return (FrontLeft.rotation(vex::rotationUnits::rev) + (BackLeft.rotation(vex::rotationUnits::rev)) + FrontRight.rotation(vex::rotationUnits::rev) + BackRight.rotation(vex::rotationUnits::rev));
    }
*/
    //timeout drive for time
    void driveTimeout(float leftTime, float rightTime){
        FrontLeft.setTimeout(leftTime, vex::timeUnits::sec);
        BackLeft.setTimeout(leftTime, vex::timeUnits::sec);
        FrontRight.setTimeout(rightTime, vex::timeUnits::sec);
        BackRight.setTimeout(rightTime, vex::timeUnits::sec);
    }

        /*-------------------------------------------------------------------------------------------*/
        /*                                                                                           */
        /*                                                                                           */
        /*  Red Auton .                                                                              */
        /*                                                                                           */
        /*                                                                                           */
        /*-------------------------------------------------------------------------------------------*/

    //if all false, run 3 flag with cap flip
    //if four flag, run 3 flag with cap flip and middle pole low flag
    //if five flag, run 3 flag with cap flip, high flag shot, and middle pole low flag
    //if park, run 3 flag with cap flip and park
    void threeFlagRed(bool fourFlag, bool fiveFlag, bool park){
       // int now = Gyro.value(vex::analogUnits::range8bit);
        //reset driveTrain encoders
        resetDrive();
        //start intake
        Intake.spin(vex::directionType::fwd, (maxSpeed * .20), vex::velocityUnits::pct);
        /*
        FrontLeft.spin(vex::directionType::fwd, 60, vex::velocityUnits::pct);
        BackLeft.spin(vex::directionType::fwd, 60, vex::velocityUnits::pct);
        BackRight.spin(vex::directionType::fwd, 60, vex::velocityUnits::pct);
        FrontRight.spin(vex::directionType::fwd, 60, vex::velocityUnits::pct);
        */
        //run drive forward for 34 inches
        //driveMoveFor(36.5, 60);
         float trevo = (36.5 / (4 * math_Pi));
         BackLeft.rotateFor(trevo, vex::rotationUnits::rev, 60, vex::velocityUnits::pct, false);
         BackRight.rotateFor(trevo, vex::rotationUnits::rev, 60, vex::velocityUnits::pct, true);
        //driveMoveFor(16.5, 70);
       // driveTurnFor(36.5, 36.5, 63, 60);
        //driveTimeout(2, 2);
        
        //delay and wait for .350 of a second
        //pick up ball
        vex::task::sleep(350);
        
        
        //gyroTurn(true, 50, 50, abs(now - Gyro.value(vex::analogUnits::range8bit)));
        //stop intake
        Intake.stop(vex::brakeType::coast); 
        //vex::task::sleep(200);
        
        //drive back 46 inches
        //hit field wall and realign
        //driveMoveFor(-46, 85);
        resetDrive();
        trevo = (-48 / (4 * math_Pi));
         BackLeft.rotateFor(trevo, vex::rotationUnits::rev, 60, vex::velocityUnits::pct, false);
         BackRight.rotateFor(trevo, vex::rotationUnits::rev, 60, vex::velocityUnits::pct, true);
        //driveTurnFor(-48, -46.5, 88, 95);
        driveTimeout(2, 2);

        //reset drive after realigning
        resetDrive();

        //vex::task::sleep(200);

        //pull back puncher to pre shoot with default value of 150
        prePuncher = true;
        //puncher now in pre shoot position

        //drive forward 10 inches for flag alignment before turning
        driveMoveFor(11, 45);
        driveTimeout(1, 1);

        //using gyro turn left to align with flags

        //start drive motors
        FrontLeft.spin(vex::directionType::rev, 40, vex::velocityUnits::pct);
        BackLeft.spin(vex::directionType::rev, 40, vex::velocityUnits::pct);
        BackRight.spin(vex::directionType::fwd, 40, vex::velocityUnits::pct);
        FrontRight.spin(vex::directionType::fwd, 40, vex::velocityUnits::pct);
        currVal = Gyro.value(vex::analogUnits::range8bit);

        while(((Gyro.value(vex::analogUnits::range8bit)) - currVal) > -50){
           vex::task::sleep(10); 
        }
        //stop motors with PID
        driveHold();
        driveTimeout(1, 1);

        //stop motors and put them on coast
        vex::task::sleep(250);
        driveCoast();

        ////drive forward to align front and back for top flag - puncher has already started
        //drive forward to align front and back for top flag - puncher has already preloaded
        driveMoveFor(2, 50);
        driveTimeout(1, 1);

        //pull back slipgear just enough to shoot
        Puncher.rotateFor(90, vex::rotationUnits::deg, 100, vex::velocityUnits::pct, true);
        Puncher.stop(vex::brakeType::hold);

        //pre pull back puncher again but with preValue as 270 to compensate
        //since first pull back was 150, and fire was 90, puncher was at 240 out of 360
        //the remaining 120 and the beginning 150 of the pull back are grouped to make 270

        puncherPreValue = 270;
        prePuncher = true;

        vex::task::sleep(100);

        //run intake to get next ball
        Intake.rotateFor(3, vex::rotationUnits::rev, (maxSpeed * .66), vex::velocityUnits::pct, false);

        //drive forward to next position for medium flag
        //driveMoveFor(21, 65); 
        
        driveCoast();
        resetDrive();
        trevo = (21 / (4 * math_Pi));
         FrontLeft.spin(vex::directionType::rev, 0, vex::velocityUnits::pct);
        BackLeft.spin(vex::directionType::rev, 0, vex::velocityUnits::pct);
        BackRight.spin(vex::directionType::fwd, 0, vex::velocityUnits::pct);
        FrontRight.spin(vex::directionType::fwd, 0, vex::velocityUnits::pct);
        
        //vex::task::sleep(2000);
        
        BackRight.rotateFor(trevo * .95, vex::rotationUnits::rev, 45, vex::velocityUnits::pct, false);
        BackLeft.rotateFor(trevo, vex::rotationUnits::rev, 45, vex::velocityUnits::pct, true);
        //vex::task::sleep(5000);
        //driveTurnFor(-48, -46.5, 88, 95);
        
        driveTimeout(1, 1);
        //driveTurnFor(24, 23.5, 70, 65);
        //driveTimeout(1.5, 1.5);
        //gyroTurn(true, 50, 50, 1);
        vex::task::sleep(250);
        //trigger puncher for medium flag shot - already in shooting position
        Puncher.rotateFor(90, vex::rotationUnits::deg, 100, vex::velocityUnits::pct, true);
        Puncher.stop(vex::brakeType::hold);

        //run puncher for 120 degrees to reset to start position - blocking off, so does this while turning and driving
        Puncher.rotateFor(120, vex::rotationUnits::deg, 100, vex::velocityUnits::pct, false);
        

        //start intake again to recycle any balls laying around
        Intake.spin(vex::directionType::fwd, (maxSpeed * .66), vex::velocityUnits::pct);
        
        //vex::task::sleep(2000);

        vex::task::sleep(100);
        //turn for low flags
        /*
        gyroTurn(false, 50, 50, 4);
        Puncher.stop(vex::brakeType::coast);
        driveMoveFor(15, 70);
        gyroTurn(true, 50, 50, 4);
        */
        ///*
        gyroTurn(false, 50, 50, 8);
        
        //drive at an angle before turning back to straight
        driveMoveFor(11, 50);

        //now that puncher is in reset position, stop mode can be coast to protect motors
        Puncher.stop(vex::brakeType::coast);

        //turn right to become straight again before hitting low flag
        gyroTurn(true, 50, 50, 8);
        //*/

        //drive forward and hit low flag
        driveMoveFor(15, 45);
        driveTimeout(1, 1);
        Intake.spin(vex::directionType::rev, (25), vex::velocityUnits::pct);

        //go slow and recycle low balls
        //driveMoveFor(5, 50);

        //drive back before turning to flip cap
        driveMoveFor(-15, 50);
        //reset lift to orig position [just in case]
       // CapIntake.rotateTo(0,vex::rotationUnits::deg, 80,vex::velocityUnits::pct, false);
       // Lift.rotateTo(0, vex::rotationUnits::deg, 85,vex::velocityUnits::pct);
            
        
        //Puncher.rotateFor(150, vex::rotationUnits::deg, 100, vex::velocityUnits::pct, false);
        Intake.spin(vex::directionType::rev, (0), vex::velocityUnits::pct);
        //turn to face towards low cap
        gyroTurn(true, 50, 50, 66);

        //start intake running backwards to flip cap
        Intake.spin(vex::directionType::rev, (maxSpeed * .85), vex::velocityUnits::pct);
        //void threeFlagRed(bool fourFlag, bool fiveFlag, bool park){

        if(park){
          //drive and flip cap
          driveMoveFor(55, 70);
          driveTimeout(1.5, 1.5);

          //turn and face platform
          gyroTurn(true, 75, 75, 35);
          driveMoveFor(52, 100);
          driveTimeout(1.5, 1.5);
        }
        else if(fourFlag){
          //drive forward to flip cap and drive enough for next shot
          driveMoveFor(52, 70);
          driveTimeout(2, 2);
          resetDrive();
          //turn and align for high flag
          gyroTurn(false, 50, 50, 34.5);
          //forward and hit low flag 
          driveMoveFor(34, 100);
          driveTimeout(1, 1);

        }
        else if(fiveFlag){
          puncherPreValue = 175;
          prePuncher = true;

          //drive forward to flip cap and drive enough for next shot
          driveMoveFor(52, 70);
          driveTimeout(2, 2);

          //turn and align for high flag
          gyroTurn(false, 50, 50, 33);

          //trigger puncher to shoot high flag - already in position
          Puncher.rotateFor(110, vex::rotationUnits::deg, 100, vex::velocityUnits::pct, true);
          Puncher.stop(vex::brakeType::hold);
  
          //run puncher for 120 degrees to reset to start position - blocking off, so does this while turning and driving
          Puncher.rotateFor(105, vex::rotationUnits::deg, 100, vex::velocityUnits::pct, false);

          //gyroTurn(false, 100, 100, 1);
          //driveMoveFor(33, 100);
          driveTurnFor(33, 36, 49, 70);
  
            //now that puncher has reset position, brake type coast can be applied
          Puncher.stop(vex::brakeType::coast);
            puncherPreValue = 150;
        }
        //none
        else {
          driveMoveFor(30, 70);
          driveTimeout(1.5, 1.5);
        }

        //end of auton stuff
        Puncher.stop(vex::brakeType::coast);
        Intake.stop(vex::brakeType::coast);
        driveLock(false);
       
    }

        /*-------------------------------------------------------------------------------------------*/
        /*                                                                                           */
        /*                                                                                           */
        /*  Blue Auton                                                                               */
        /*                                                                                           */
        /*                                                                                           */
        /*-------------------------------------------------------------------------------------------*/

    //same as threeFlagRed, but blue
    //if all false, run 3 flag with cap flip
    //if four flag, run 3 flag with cap flip and middle pole low flag
    //if five flag, run 3 flag with cap flip, high flag shot, and middle pole low flag
    //if park, run 3 flag with cap flip and park
    void threeFlagBlue(bool fourFlag, bool fiveFlag, bool park){
       // int now = Gyro.value(vex::analogUnits::range8bit);
        //reset driveTrain encoders
        resetDrive();
        //start intake
        Intake.spin(vex::directionType::fwd, (maxSpeed * .20), vex::velocityUnits::pct);
        /*
        FrontLeft.spin(vex::directionType::fwd, 60, vex::velocityUnits::pct);
        BackLeft.spin(vex::directionType::fwd, 60, vex::velocityUnits::pct);
        BackRight.spin(vex::directionType::fwd, 60, vex::velocityUnits::pct);
        FrontRight.spin(vex::directionType::fwd, 60, vex::velocityUnits::pct);
        */
        //run drive forward for 34 inches
        //driveMoveFor(36.5, 60);
         float trevo = (36.5 / (4 * math_Pi));
         BackLeft.rotateFor(trevo, vex::rotationUnits::rev, 60, vex::velocityUnits::pct, false);
         BackRight.rotateFor(trevo, vex::rotationUnits::rev, 60, vex::velocityUnits::pct, true);
        //driveMoveFor(16.5, 70);
       // driveTurnFor(36.5, 36.5, 63, 60);
        //driveTimeout(2, 2);
        
        //delay and wait for .350 of a second
        //pick up ball
        vex::task::sleep(350);
        
        //gyroTurn(true, 50, 50, abs(now - Gyro.value(vex::analogUnits::range8bit)));
        //stop intake
        Intake.stop(vex::brakeType::coast); 
        //vex::task::sleep(200);
        
        //drive back 46 inches
        //hit field wall and realign
        //driveMoveFor(-46, 85);
        resetDrive();
        trevo = (-48 / (4 * math_Pi));
        BackLeft.rotateFor(trevo, vex::rotationUnits::rev, 75, vex::velocityUnits::pct, false);
        BackRight.rotateFor(trevo, vex::rotationUnits::rev, 75, vex::velocityUnits::pct, true);
        //driveTurnFor(-48, -46.5, 88, 95);
        driveTimeout(3, 3);

        //reset drive after realigning
        resetDrive();

        //vex::task::sleep(200);

        //pull back puncher to pre shoot with default value of 150
        prePuncher = true;
        //puncher now in pre shoot position

        //drive forward 10 inches for flag alignment before turning
        driveMoveFor(10.5, 35);
        driveTimeout(1, 1);

        //using gyro turn left to align with flags

        //start drive motors
        FrontLeft.spin(vex::directionType::fwd, 40, vex::velocityUnits::pct);
        BackLeft.spin(vex::directionType::fwd, 40, vex::velocityUnits::pct);
        BackRight.spin(vex::directionType::rev, 40, vex::velocityUnits::pct);
        FrontRight.spin(vex::directionType::rev, 40, vex::velocityUnits::pct);
        currVal = Gyro.value(vex::analogUnits::range8bit);

        while(((Gyro.value(vex::analogUnits::range8bit)) - currVal) < 53){
           vex::task::sleep(10); 
        }
        //stop motors with PID
        driveHold();
        driveTimeout(1, 1);

        //stop motors and put them on coast
        vex::task::sleep(250);
        driveCoast();

        ////drive forward to align front and back for top flag - puncher has already started
        //drive forward to align front and back for top flag - puncher has already preloaded
        driveMoveFor(2, 50);
        driveTimeout(1, 1);

        //pull back slipgear just enough to shoot
        Puncher.rotateFor(90, vex::rotationUnits::deg, 100, vex::velocityUnits::pct, true);
        Puncher.stop(vex::brakeType::hold);

        //pre pull back puncher again but with preValue as 270 to compensate
        //since first pull back was 150, and fire was 90, puncher was at 240 out of 360
        //the remaining 120 and the beginning 150 of the pull back are grouped to make 270

        puncherPreValue = 270;
        prePuncher = true;

        vex::task::sleep(100);

        //run intake to get next ball
        Intake.rotateFor(3, vex::rotationUnits::rev, (maxSpeed * .5), vex::velocityUnits::pct, false);

        //drive forward to next position for medium flag
        //driveMoveFor(21, 60);
        resetDrive();
        driveCoast();
        FrontLeft.spin(vex::directionType::fwd, 0, vex::velocityUnits::pct);
        BackLeft.spin(vex::directionType::fwd, 0, vex::velocityUnits::pct);
        BackRight.spin(vex::directionType::fwd, 0, vex::velocityUnits::pct);
        FrontRight.spin(vex::directionType::fwd, 0, vex::velocityUnits::pct);
        trevo = (19 / (4 * math_Pi));
        
        BackLeft.rotateFor(trevo, vex::rotationUnits::rev, 75, vex::velocityUnits::pct, false);
        BackRight.rotateFor(trevo, vex::rotationUnits::rev, 75, vex::velocityUnits::pct, true);
        driveTimeout(1, 1);
        

        vex::task::sleep(250);
        //trigger puncher for medium flag shot - already in shooting position
        Puncher.rotateFor(90, vex::rotationUnits::deg, 100, vex::velocityUnits::pct, true);
        Puncher.stop(vex::brakeType::hold);

        //run puncher for 120 degrees to reset to start position - blocking off, so does this while turning and driving
        Puncher.rotateFor(120, vex::rotationUnits::deg, 100, vex::velocityUnits::pct, false);

        //start intake again to recycle any balls laying around
        Intake.spin(vex::directionType::fwd, (maxSpeed * .66), vex::velocityUnits::pct);
        
        //vex::task::sleep(2000);

        vex::task::sleep(100);
        //turn for low flags
        /*
        gyroTurn(false, 50, 50, 4);
        Puncher.stop(vex::brakeType::coast);
        driveMoveFor(15, 70);
        gyroTurn(true, 50, 50, 4);
        */
        ///*
        //first low flag turn
        gyroTurn(true, 50, 50, 6);
        
        //drive at an angle before turning back to straight
        driveMoveFor(5.2, 50);

        //now that puncher is in reset position, stop mode can be coast to protect motors
        Puncher.stop(vex::brakeType::coast);

        //turn right to become straight again before hitting low flag
        gyroTurn(false, 50, 50, 6);
        //*/

        //drive forward and hit low flag
        driveMoveFor(22, 75);

        //go slow and recycle low balls
        //driveMoveFor(5, 50);

        //drive back before turning to flip cap
        Intake.spin(vex::directionType::rev, (maxSpeed * .25), vex::velocityUnits::pct);
        driveMoveFor(-15, 75);
        //reset lift to orig position [just in case]
       // CapIntake.rotateTo(0,vex::rotationUnits::deg, 80,vex::velocityUnits::pct, false);
       // Lift.rotateTo(0, vex::rotationUnits::deg, 85,vex::velocityUnits::pct);
            
        //turn to face towards low cap
        gyroTurn(false, 50, 50, 67);

        //start intake running backwards to flip cap
        Intake.spin(vex::directionType::rev, (maxSpeed * .75), vex::velocityUnits::pct);
        //void threeFlagRed(bool fourFlag, bool fiveFlag, bool park){

        if(park){
          //drive and flip cap
          driveMoveFor(52, 70);
          driveTimeout(1.5, 1.5);

          //turn and face platform
          gyroTurn(false, 75, 75, 45);
          driveMoveFor(52, 100);
          driveTimeout(2, 2);
        }
        else if(fourFlag){
            //drive forward to flip cap and drive enough for next shot
          driveMoveFor(52, 70);
          driveTimeout(2, 2);
          resetDrive();
          //turn and align for low flag
          gyroTurn(true, 50, 50, 39);
        

          //forward and hit low flag 
          driveMoveFor(34, 100);
          driveTimeout(1, 1);
          //driveTurnFor(31, 22, 100, 70);

        }
        else if(fiveFlag){
          prePuncher = true;

          //drive forward to flip cap and drive enough for next shot
          driveMoveFor(52, 70);
          driveTimeout(2, 2);

          //turn and align for high flag
          gyroTurn(true, 50, 50, 38);

          //trigger puncher to shoot high flag - already in position
          Puncher.rotateFor(90, vex::rotationUnits::deg, 100, vex::velocityUnits::pct, true);
          Puncher.stop(vex::brakeType::hold);
  
          //run puncher for 120 degrees to reset to start position - blocking off, so does this while turning and driving
          Puncher.rotateFor(120, vex::rotationUnits::deg, 100, vex::velocityUnits::pct, false);
            
            resetDrive();
          //turn more towards low flag
          driveTurnFor(36, 33, 70, 40);
  
            //now that puncher has reset position, brake type coast can be applied
          Puncher.stop(vex::brakeType::coast);
        }
        //none
        else {
          driveMoveFor(30, 70);
          driveTimeout(1.5, 1.5);
        }
        
        
        //end of auton stuff
        Puncher.stop(vex::brakeType::coast);
        Intake.stop(vex::brakeType::coast);
        driveLock(false);
    }

    void backblueParking(){
        resetDrive();
        driveMoveFor(20, 30);
 
        vex::task::sleep(7000);

        Puncher.rotateFor(360, vex::rotationUnits::deg, 100, vex::velocityUnits::pct, true);
        Puncher.stop(vex::brakeType::coast);

        driveMoveFor(-20, 30);
        resetDrive();
        gyroTurn(false, 50, 50, 16);
        resetDrive();

        Intake.spin(vex::directionType::fwd, (maxSpeed * .20), vex::velocityUnits::pct);

        trevo = (48 / (4 * math_Pi));
        BackLeft.rotateFor(trevo, vex::rotationUnits::rev, 50, vex::velocityUnits::pct, false);
        BackRight.rotateFor(trevo, vex::rotationUnits::rev, 50, vex::velocityUnits::pct, true);
        driveCoast();
        resetDrive();
        
        driveMoveFor(-20, 100);
        gyroTurn(true, 50, 50, 49);
        resetDrive();
        Intake.spin(vex::directionType::fwd, (0), vex::velocityUnits::pct);
        driveMoveFor(45, 100);
    }

    void backBlueTesting(){
        resetDrive();
        //drive forward
        //driveMoveFor(20, 30);
        trevo = (20 / (4 * math_Pi));
        BackLeft.rotateFor(trevo, vex::rotationUnits::rev, 30, vex::velocityUnits::pct, false);
        BackRight.rotateFor(trevo, vex::rotationUnits::rev, 30, vex::velocityUnits::pct, true);
        driveCoast();
        resetDrive();

        //wait 7 seconds before shooting
        vex::task::sleep(500);

        //shoot puncher
        Puncher.rotateFor(360, vex::rotationUnits::deg, 100, vex::velocityUnits::pct, true);
        Puncher.stop(vex::brakeType::coast);

        //drive back
        // driveMoveFor(-20, 30);
        trevo = (-20 / (4 * math_Pi));
        BackLeft.rotateFor(trevo, vex::rotationUnits::rev, 70, vex::velocityUnits::pct, false);
        BackRight.rotateFor(trevo, vex::rotationUnits::rev, 70, vex::velocityUnits::pct, true);
        driveCoast();
        resetDrive();
        vex::task::sleep(150);

        //turn and align for cap
        resetDrive();
        gyroTurn(false, 50, 50, 16);

        vex::task::sleep(150);

        //align against back wall
        resetDrive();
        
        driveCoast();
        driveMoveFor(-5, 50);
        resetDrive();
        driveCoast();

        //start intake
        Intake.spin(vex::directionType::fwd, (maxSpeed * .20), vex::velocityUnits::pct);

        //drive forward and get ball
        trevo = (52 / (4 * math_Pi));
        BackLeft.rotateFor(trevo, vex::rotationUnits::rev, 60, vex::velocityUnits::pct, false);
        BackRight.rotateFor(trevo, vex::rotationUnits::rev, 60, vex::velocityUnits::pct, true);
        driveCoast();
        resetDrive();


        vex::task::sleep(350);
        //drive back before turning for other low cap
        trevo = (-13 / (4 * math_Pi));
        BackLeft.rotateFor(trevo, vex::rotationUnits::rev, 70, vex::velocityUnits::pct, false);
        BackRight.rotateFor(trevo, vex::rotationUnits::rev, 70, vex::velocityUnits::pct, true);
        driveCoast();
        resetDrive();
        vex::task::sleep(150);

        //turn so lift can flip other low cap
        gyroTurn(true, 50, 50, 70);

        //put cappy boi out
       // CapIntake.rotateTo(-385,vex::rotationUnits::deg, 100, vex::velocityUnits::pct, true);

        vex::task::sleep(150);
        resetDrive();

        //drive into cap
        trevo = (-24 / (4 * math_Pi));
        BackLeft.rotateFor(trevo, vex::rotationUnits::rev, 70, vex::velocityUnits::pct, false);
        BackRight.rotateFor(trevo, vex::rotationUnits::rev, 70, vex::velocityUnits::pct, true);
        driveCoast();
        resetDrive();     
        vex::task::sleep(150);

        //flip cap onto lexan
       // CapIntake.rotateTo(-60, vex::rotationUnits::deg, 60,vex::velocityUnits::pct);
        //vex::task::sleep(250);
        //CapIntake.rotateTo(-400, vex::rotationUnits::deg, 85, vex::velocityUnits::pct);

        //drive back
        driveMoveFor(15, 70);

        //rotate cap boi in

        //turn back to alignment
        //gyroTurn(false, 30, 30, 30);

        //drive back to align with platform
        //driveMoveFor(-10, 70);

        //turn to face platform
        gyroTurn(false, 70, 70, 10);
         //CapIntake.rotateTo(0, vex::rotationUnits::deg, 60,vex::velocityUnits::pct, false);

        //drive onto platform
        driveMoveFor(40, 100);
        driveTimeout(2000, 2000);
                Intake.spin(vex::directionType::fwd, (0 * .20), vex::velocityUnits::pct);

    }

    void backredParking(){
        resetDrive();
        driveMoveFor(20, 30);
 
        vex::task::sleep(7000);

        Puncher.rotateFor(360, vex::rotationUnits::deg, 100, vex::velocityUnits::pct, true);
        Puncher.stop(vex::brakeType::coast);

        driveMoveFor(-20, 30);
        resetDrive();
        gyroTurn(true, 50, 50, 15);
        resetDrive();

        Intake.spin(vex::directionType::fwd, (maxSpeed * .20), vex::velocityUnits::pct);

        trevo = (48 / (4 * math_Pi));
        BackLeft.rotateFor(trevo, vex::rotationUnits::rev, 50, vex::velocityUnits::pct, false);
        BackRight.rotateFor(trevo, vex::rotationUnits::rev, 50, vex::velocityUnits::pct, true);
        driveCoast();
        resetDrive();
        
        driveMoveFor(-20, 100);
        gyroTurn(false, 50, 50, 49);
        resetDrive();
        Intake.spin(vex::directionType::fwd, (0), vex::velocityUnits::pct);
        driveMoveFor(45, 100);
    }

    void backRedTesting(){
        resetDrive();

        //drive forward
        //driveMoveFor(20, 30);
        trevo = (20 / (4 * math_Pi));
        BackLeft.rotateFor(trevo, vex::rotationUnits::rev, 30, vex::velocityUnits::pct, false);
        BackRight.rotateFor(trevo, vex::rotationUnits::rev, 30, vex::velocityUnits::pct, true);
        driveCoast();
        resetDrive();

        //wait 7 seconds before shooting
        vex::task::sleep(500);

        //shoot puncher
        Puncher.rotateFor(360, vex::rotationUnits::deg, 100, vex::velocityUnits::pct, true);
        Puncher.stop(vex::brakeType::coast);

        //drive back
        // driveMoveFor(-20, 30);
        trevo = (-20 / (4 * math_Pi));
        BackLeft.rotateFor(trevo, vex::rotationUnits::rev, 70, vex::velocityUnits::pct, false);
        BackRight.rotateFor(trevo, vex::rotationUnits::rev, 70, vex::velocityUnits::pct, true);
        driveCoast();
        resetDrive();
        vex::task::sleep(150);

        //turn and align for cap
        resetDrive();
        gyroTurn(true, 50, 50, 16);

        vex::task::sleep(150);

        //align against back wall
        resetDrive();
        
        driveCoast();
        driveMoveFor(-5, 50);
        resetDrive();
        driveCoast();

        //start intake
        Intake.spin(vex::directionType::fwd, (maxSpeed * .20), vex::velocityUnits::pct);

        //drive forward and get ball
        trevo = (52 / (4 * math_Pi));
        BackLeft.rotateFor(trevo, vex::rotationUnits::rev, 60, vex::velocityUnits::pct, false);
        BackRight.rotateFor(trevo, vex::rotationUnits::rev, 60, vex::velocityUnits::pct, true);
        driveCoast();
        resetDrive();


        vex::task::sleep(350);
        //drive back before turning for other low cap
        trevo = (-13 / (4 * math_Pi));
        BackLeft.rotateFor(trevo, vex::rotationUnits::rev, 70, vex::velocityUnits::pct, false);
        BackRight.rotateFor(trevo, vex::rotationUnits::rev, 70, vex::velocityUnits::pct, true);
        driveCoast();
        resetDrive();
        vex::task::sleep(150);

        //turn so lift can flip other low cap
        gyroTurn(false, 50, 50, 70);

        //put cappy boi out
        //CapIntake.rotateTo(-385,vex::rotationUnits::deg, 100, vex::velocityUnits::pct, true);

        vex::task::sleep(150);
        resetDrive();

        //drive into cap
        trevo = (-24 / (4 * math_Pi));
        BackLeft.rotateFor(trevo, vex::rotationUnits::rev, 70, vex::velocityUnits::pct, false);
        BackRight.rotateFor(trevo, vex::rotationUnits::rev, 70, vex::velocityUnits::pct, true);
        driveCoast();
        resetDrive();     
        vex::task::sleep(150);

        //flip cap onto lexan
        //CapIntake.rotateTo(-60, vex::rotationUnits::deg, 60,vex::velocityUnits::pct);
        //vex::task::sleep(250);
        //CapIntake.rotateTo(-400, vex::rotationUnits::deg, 85, vex::velocityUnits::pct);

        //drive back
        driveMoveFor(15, 70);

        //rotate cap boi in

        //turn back to alignment
        //gyroTurn(false, 30, 30, 30);

        //drive back to align with platform
        //driveMoveFor(-10, 70);

        //turn to face platform
        gyroTurn(true, 70, 70, 10);
         //CapIntake.rotateTo(0, vex::rotationUnits::deg, 60,vex::velocityUnits::pct, false);

        //drive onto platform
        driveMoveFor(40, 100);
        driveTimeout(2000, 2000);
                Intake.spin(vex::directionType::fwd, (0 * .20), vex::velocityUnits::pct);

    }

void autonomous( void ) {
    //run auton helper task
    vex::task autoHelp(autoTask);
    
    /*  all false = just 3 flag with cap flip
        if first bool true, 4 flag
        if second bool true, 5 flag
        if third bool true, parking auton
        (bool fourFlag, bool fiveFlag, bool park)
    */
    
    //3 flag function - red side
    //5 flag
      threeFlagRed(false, true, false);
    //4 flag
      //threeFlagRed(true, false, false);
    //3 flag
      //threeFlagRed(false, false, false);
    //parking
      //threeFlagRed(false, true, true);


    //3 flag function - blue side
    //5 flag
      //threeFlagBlue(false, true, false);
    //4 flag
      //threeFlagBlue(true, false, false);
    //3 flag
      //threeFlagBlue(false, false, false);
    //parking
      //threeFlagBlue(false, true, true);

    //back red testing
    //backRedTesting();

    //back blue testing
    //backBlueTesting();

        
    //back side - red
    //backredParking();

    //back side - blue
    //backblueParking();

    //stop auto helper task
    vex::task stop(autoTask); 
    //just in case
    vex::task::sleep(15000);
}


    void autoAngle(){
        //if puncher trigger is clicked
        //high flags
        if(angleTrigger){
            if(anglePos == 0){
                angleAdjust.rotateTo(0,vex::rotationUnits::deg,100,vex::velocityUnits::pct);
                angleAdjust.setTimeout(600, vex::timeUnits::msec);

                //angleAdjust.stop(vex::brakeType::coast);

            }
            //medium flag
            else if(anglePos == 1){
                angleAdjust.rotateTo(120,vex::rotationUnits::deg,100,vex::velocityUnits::pct);
                angleAdjust.setTimeout(600, vex::timeUnits::msec);


            }
            //lowest flag
            else if(anglePos == 2){
                 angleAdjust.rotateTo(262,vex::rotationUnits::deg,100,vex::velocityUnits::pct);
                 angleAdjust.setTimeout(600, vex::timeUnits::msec);



            }
            angleTrigger = false;
        }
    }
    
    void angleTriggerDetect(){
            //toggle between high and medium
            if(Controller1.ButtonUp.pressing()){
            //wait until released
               while(Controller1.ButtonUp.pressing()){
                   vex::task::sleep(100);
               }
            //run func
               if(anglePos != 2){
            angleTrigger = true;
            anglePos = 1 - anglePos;
        }
            }  

            //lowest flag toggle
            else if(Controller1.ButtonRight.pressing()){
                //wait until released
               while(Controller1.ButtonRight.pressing()){
                   vex::task::sleep(100);
               }
            //run func
            angleTrigger = true;

            anglePos = 2 - anglePos;
            }


            //motor holds
            if(!angleTrigger){
            if(anglePos == 0)
                angleAdjust.stop(vex::brakeType::coast);
            
            //medium flag
            else if(anglePos == 1)
                angleAdjust.stop(vex::brakeType::hold);
            
            //lowest flag
            else if(anglePos == 2)
                 angleAdjust.stop(vex::brakeType::hold);
         }

        }
    

    

    void driveLockDetect(){
        if(Controller1.ButtonLeft.pressing()){
           //wait until released
           while(Controller1.ButtonLeft.pressing()){
               vex::task::sleep(100);
           }
           //run func
            driveLockOn = !driveLockOn;
           driveLock(driveLockOn);
       }
    }

    
    //lift down
    
    void autoLiftReset(){
        if(liftReset){
        Lift.rotateTo(0, vex::rotationUnits::deg, 85,vex::velocityUnits::pct);
        liftOn = false;
        //timeout
        liftReset = false;
        }
    }

    void liftResetDetect(){
                if(Controller1.ButtonA.pressing()){
                //wait until released
                   while(Controller1.ButtonA.pressing()){
                       vex::task::sleep(100);
                   }
                //run func
                liftReset = true;
                }  
    }



    void autoLiftMedium(){
        if(liftMedium){
        Lift.rotateTo(360, vex::rotationUnits::deg, 85, vex::velocityUnits::pct);
        liftOn = true;
        //timeout
        liftMedium = false;
        }
    }

    void liftMediumDetect(){
    	if(Controller1.ButtonY.pressing()){
                //wait until released
                   while(Controller1.ButtonY.pressing()){
                       vex::task::sleep(100);
                   }
                //run func
                liftMedium = true;
                }  
    }


    


    void driveTaskFunc(){
        //the functions that run in this "othertask"
        
        //actions
        autoAngle();
       
        //puncher auto button
        angleTriggerDetect();
        
        //drive lock for platform
        driveLockDetect();
    }

void liftTaskFunc(){
        //the functions that run in this "othertask"
        
        //actions
        autoLiftReset();
        autoLiftMedium();
        
        //detections
        liftResetDetect();
        liftMediumDetect();
        
        
    }
    
//other task used to run puncher and cap intake triggers
    int driveTask(){
        while(true){
            driveTaskFunc();
            //to not waste resources
            vex::task::sleep(20);
        }
        return 0;
    }

int liftTask(){
        while(true){
            liftTaskFunc();
            //to not waste resources
            vex::task::sleep(20);
        }
        return 0;
    }



    void controllerDisplay(){
            Controller1.Screen.clearScreen();


                    if(!driveLockOn){
                    Controller1.Screen.setCursor(3, 1);
                    //Controller1.Screen.print("               Off");
                    Controller1.Screen.print("Off");
                	}
                	else
                	{
                		Controller1.Screen.setCursor(3, 1);
                    Controller1.Screen.print("On");
                	}
        
                    Controller1.Screen.setCursor(1,1);
                    if(anglePos == 0){
                        Controller1.Screen.print("High");
                    }
                    else if(anglePos == 1){
                        Controller1.Screen.print("Medium");
                    }
                    else{
                        Controller1.Screen.print("Low");
                    }
                
                     
        }

    void brainDisplay(){
        Brain.Screen.clearScreen();
        /*
            //Brain.Screen.printAt(1, 40, "%d", capTrigger);
            //Brain.Screen.printAt(1, 120, "%d", capResetTrigger);
            //Brain.Screen.printAt(1, 80, "%d", angleTrigger);
            //Brain.Screen.printAt(1, 120, "%d", test);
            Brain.Screen.printAt(1, 15, "%d", Gyro.value(vex::analogUnits::pct));
              Brain.Screen.printAt(1, 35, "%d", Gyro.value(vex::analogUnits::range8bit));
              Brain.Screen.printAt(1, 55, "%d", Gyro.value(vex::analogUnits::range10bit));
              Brain.Screen.printAt(1, 55, "%d", Gyro.value(vex::analogUnits::range12bit));
              Brain.Screen.printAt(1, 75, "%d", Gyro.value(vex::analogUnits::mV));
            
              //Brain.Screen.printAt(1, 115, "%d", Gyro.value(vex::rotationUnits::deg));
            
              Brain.Screen.printAt(1, 155, "%d", Gyro.value(vex::percentUnits::pct));
              Brain.Screen.printAt(1, 180, "%d", liftReset);
         */
        //Brain.Screen.printAt(1, 40, "5flagRed");
        
        //vision sensor testing
        
          
    }



    //task only used to update brain and controller displays
    //also used to select auton's
    int displayTask(){
        while(true){
            controllerDisplay();
            brainDisplay();
            //to not waste resources - 150 cause display doesn't need to be updated super fast
            vex::task::sleep(150);
        }
        return 0;
    }

    
    void driveTrainControl(void){
        
        //lock drive if joysticks not moved
      /*  if((abs(Controller1.Axis2.value()) < 15) && (abs(Controller1.Axis3.value()) < 15)) {
            driveLock(true);     
        }
        */
        //else
        //if(driveType){

        if(puncherIsMoving){
            FrontLeft.spin(vex::directionType::fwd, Controller1.Axis3.value() * .3, vex::velocityUnits::pct);
            BackLeft.spin(vex::directionType::fwd, Controller1.Axis3.value() * .3, vex::velocityUnits::pct);
            FrontRight.spin(vex::directionType::fwd, Controller1.Axis2.value() * .3, vex::velocityUnits::pct);
            BackRight.spin(vex::directionType::fwd, Controller1.Axis2.value() * .3, vex::velocityUnits::pct);
        }
        else {
            int temp = Controller1.Axis3.value();
            int temp2 = Controller1.Axis3.value();
            FrontLeft.spin(vex::directionType::fwd, Controller1.Axis3.value() * 1.0, vex::velocityUnits::pct);
            BackLeft.spin(vex::directionType::fwd, Controller1.Axis3.value() * 1.0, vex::velocityUnits::pct);
            FrontRight.spin(vex::directionType::fwd, Controller1.Axis2.value() * 1.0, vex::velocityUnits::pct);
            BackRight.spin(vex::directionType::fwd, Controller1.Axis2.value() * 1.0, vex::velocityUnits::pct);
        }
            
        //}
       // else {
         //   FrontLeft.spin(vex::directionType::rev, Controller1.Axis2.value() * .9, vex::velocityUnits::pct);
         //   BackLeft.spin(vex::directionType::rev, Controller1.Axis2.value() * .9, vex::velocityUnits::pct);
         //   FrontRight.spin(vex::directionType::rev, Controller1.Axis3.value() * .9, vex::velocityUnits::pct);
         //   BackRight.spin(vex::directionType::rev, Controller1.Axis3.value() * .9, vex::velocityUnits::pct);
        //}
    }

    //intake control for roller
    //if drivetype is true, run shooting mode
    void IntakeControl(void){

            if(Controller1.ButtonL2.pressing()){
                Intake.spin(vex::directionType::fwd, (maxSpeed * 1), vex::velocityUnits::pct);
            }
            else if(Controller1.ButtonL1.pressing()){
                Intake.spin(vex::directionType::rev, (maxSpeed * 1), vex::velocityUnits::pct);
            }
            else {
                Intake.stop(vex::brakeType::coast);
            }
        }
    
    
    void PuncherControl(void){
    //button  

                        /*
                if(Controller1.ButtonR1.pressing()){
                    Puncher.spin(vex::directionType::rev, maxSpeed / 1.5, vex::velocityUnits::pct);
                }
                
                else */if(Controller1.ButtonR2.pressing()){
    				liftOn = false;
                    puncherIsMoving = true;
                    Puncher.spin(vex::directionType::fwd, maxSpeed, vex::velocityUnits::pct);

                    //turn lift holding off if shooting
                    /*if(liftActivate){
                      liftActivate = false;
                    }
                    */

                }
                
                else {
                    puncherIsMoving = false;
                    Puncher.stop(vex::brakeType::coast);
                    //Puncher.stop(vex::brakeType::brake);
                }
                
        }
    
    void LiftControl(void){

        if(Controller1.ButtonX.pressing()){
                Lift.spin(vex::directionType::fwd, maxSpeed * .60, vex::velocityUnits::pct);
                liftOn = false;
            }
        else if(Controller1.ButtonB.pressing()){
                    Lift.spin(vex::directionType::rev, (maxSpeed * .60), vex::velocityUnits::pct);
                    liftOn = false;
            }
        else if((!liftMedium) && (!liftReset)){
        	if(liftOn){
                Lift.stop(vex::brakeType::hold);     
        	}
            else if (!liftOn){
            	Lift.stop(vex::brakeType::coast);
            }
        	
        }
    
    }
        
        
    void allRemoteFunc(void){
       // CapIntakeControl();
        LiftControl();
        PuncherControl();
        IntakeControl();
        driveTrainControl();      
    }

void usercontrol( void ) {
  // User control code here, inside the loop
    
  //initiate task for triggers, like cap control and puncher button
  vex::task driveTriggers(driveTask, 1);
  vex::task liftTriggers(liftTask, 2);
  
  //initiate task for brain and controller displays
  vex::task display(displayTask, 3);
        Puncher.stop(vex::brakeType::coast);
        Intake.stop(vex::brakeType::coast);
        driveCoast();
    
  while (true) {
    allRemoteFunc();                
    vex::task::sleep(20); //Sleep the task for a short amount of time to prevent wasted resources. 
  }
}

int main() {
    
    //Run the pre-autonomous function. 
    pre_auton();
    
    
    //Set up callbacks for autonomous and driver control periods.
    Competition.autonomous(autonomous);
    Competition.drivercontrol(usercontrol);

    //Prevent main from exiting with an infinite loop.                        
    while(true) {
      vex::task::sleep(100);//Sleep the task for a short amount of time to prevent wasted resources.
    }    
       
}	