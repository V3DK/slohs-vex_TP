#include "robot-config.h"

//Creates a competition object that allows access to Competition methods.
vex::competition    Competition;

/*--------------------------------------------------------------------------
Joysticks - Tank Control
Left - Drive Lock

Displays Drive Mode on Controller

Flags: 
Joystick - Intake Side as Forward
R2 - Puncher Trigger [Once pressed, runs task to run puncher 360 degrees]
R1 - Puncher Ratchet [Once pressed, runs task to run puncher 180 degrees]
Up - Toggle for High/Medium Angle-Adjusting
Right - Toggle for High/Low Angle-Adjusting
L2 - Intake In
L1 - Intake Out


Caps:
A - Reset Lift Down
B - Lift Down [Manual Contro]
X - Lift Up [Manual Contro]
Y - Medium Lift Hold
--------------------------------------------------------------------------*/

int maxSpeed = 100;
int trevo = 0;
int joyVal = 0;

int pLastVal = 0;

//used to calculate driving distances in auton
float math_Pi = 3.1415926535897932384626433;

bool autoRunning = false;
/*
if 0 - down (high flag)
if 1 - middle (medium flag)
if 2 - up (low flag)
*/
//angle and puncher bools
bool pLoaded = false;
int anglePos = 0;
bool angleTrigger = false;

//drive bools
bool driveLockOn = false;

//scrapper bools
bool scrapperUp = false;
bool scrapperPos = false;
bool scrapperEnabled = false;
//false = in
//true = out
// PID TESTING
//pid is running or not
bool pidRunning = false;
bool lDone = true;
bool rDone = true;
bool sideErrorRunning = false;
//reqeusted value to get to

//left
float pidReqValueL = 0; 
//right
float pidReqValueR = 0; 

//max speed for pid to go at
int pidSpeedL = 0;
int pidSpeedR = 0;

//constants for control
float  pid_Kp = 0.45;
float  pid_Ki = 0.1;
float  pid_Kd = 0.0;
float pid_sKp = 0.25;
void resetDrive(){
    FrontLeft.resetRotation();
    BackLeft.resetRotation();
    FrontRight.resetRotation();
    BackRight.resetRotation();
    }
//move drive at speed s
    /*
void driveSpeed(float s){
    FrontLeft.spin(vex::directionType::fwd, s, vex::velocityUnits::pct);
    BackLeft.spin(vex::directionType::fwd, s, vex::velocityUnits::pct);
    FrontRight.spin(vex::directionType::fwd, s, vex::velocityUnits::pct);
    BackRight.spin(vex::directionType::fwd, s, vex::velocityUnits::pct);
}
*/


//return the avg value of left encoders
float leftAvg(){
    //avg the 2 values
    return ((FrontLeft.rotation(vex::rotationUnits::deg) + 
            BackLeft.rotation(vex::rotationUnits::deg)) / 2);
}


//return the avg value of left encoders
float rightAvg(){
    //avg the 2 values
    return ((FrontRight.rotation(vex::rotationUnits::deg) + 
            BackRight.rotation(vex::rotationUnits::deg)) / 2);
}



//stop the pid part from running and reset values passed
 void stopPid(){
 	sideErrorRunning = false;
    pidRunning = false;

    FrontLeft.spin(vex::directionType::fwd, 0, vex::velocityUnits::pct);
    BackLeft.spin(vex::directionType::fwd, 0, vex::velocityUnits::pct);
    FrontRight.spin(vex::directionType::fwd, 0, vex::velocityUnits::pct);
    BackRight.spin(vex::directionType::fwd, 0, vex::velocityUnits::pct);

    pidReqValueL = 0;
    pidSpeedL = 0;

    pidReqValueR = 0;
    pidSpeedR = 0;
 }

 //start driving pid for req value at speed
 //run pidLoop for pTime before stopping it
 //pTime in seconds
 void startPid(float pReqL, int pSpeedL, float pReqR, int pSpeedR){
    resetDrive();
    pidReqValueL = pReqL;
    pidSpeedL = pSpeedL;
    lDone = false;

    pidReqValueR = pReqR;
    pidSpeedR = pSpeedR;
    rDone = false;

   // Brain.Screen.clearScreen();
    //Brain.Screen.printAt(1, 15, "%.6f", pidReqValue);
    //Brain.Screen.printAt(1, 35, "%d", pidSpeed);
    sideErrorRunning = true;
    pidRunning = true;

    //wait until pidRunning is false
    while(pidRunning != false){
        vex::task::sleep(25);
    }
    //Brain.Screen.printAt(1, 115, "Done!");

 }

int pidTask(){
    float  pidCurrValueL;
    int    pidErrorL;
    float  pidLastErrorL;
    float  pidIntegralL;
    float  pidDerivativeL;
    int    pidDriveL;

    float  pidCurrValueR;
    int    pidErrorR;
    float  pidLastErrorR;
    float  pidIntegralR;
    float  pidDerivativeR;
    int    pidDriveR;

    float    sideError;

    //clearEncoders
    resetDrive();

    pidLastErrorL = 0;
    pidIntegralL = 0;
    pidLastErrorR = 0;
    pidIntegralR = 0;

     while(true){

       // Brain.Screen.printAt(1, 120, "%d", pidRunning);

        if(pidRunning){
            Brain.Screen.clearScreen();

            //read sensor value from drive Avg func
            pidCurrValueL = leftAvg();
            pidCurrValueR = rightAvg();

            //calculate error
            pidErrorL = pidReqValueL - pidCurrValueL;
            pidErrorR = pidReqValueR - pidCurrValueR;


            //if integral constant isn't 0 -> we want to use it
             if(pid_Ki != 0.0) {
                // If we are inside controlable window then integrate the error
                if(abs(pidErrorL) < 10)
                    pidIntegralL = pidIntegralL + pidErrorL;
                else
                    pidIntegralL = 0;
                }
            else {
                pidIntegralL = 0;
            }

            if(pid_Ki != 0.0) {
                // If we are inside controlable window then integrate the error
                if(abs(pidErrorR) < 10)
                    pidIntegralR = pidIntegralR + pidErrorR;
                else
                    pidIntegralR = 0;
                }
            else {
                pidIntegralR = 0;
            }

            //pidIntegralL = 0;
            //pidIntegralR = 0;
            // calculate the derivative
            //pidDerivative = pidError - pidLastError;
            //restore lastError value
            pidLastErrorL = pidErrorL;
            pidLastErrorR = pidErrorR;
            //calculate drive (what to send to motors)
            pidDriveL = (pid_Kp * pidErrorL) + (pid_Ki * pidIntegralL) + (pid_Kd * pidDerivativeL);

            pidDriveR = (pid_Kp * pidErrorR) + (pid_Ki * pidIntegralR) + (pid_Kd * pidDerivativeR);
            //limit drive - speed based on pidSpeed variable passed in
            if(pidDriveL > pidSpeedL)
                pidDriveL = pidSpeedL;
            else if(pidDriveL < (-1 * pidSpeedL))
                pidDriveL = (-1 * pidSpeedL);

            //limit drive - speed based on pidSpeed variable passed in
            if(pidDriveR > pidSpeedR)
                pidDriveR = pidSpeedR;
            else if(pidDriveR < (-1 * pidSpeedR))
                pidDriveR = (-1 * pidSpeedR);

           // Brain.Screen.clearScreen();
            //stoppping state - if drive power super small, (less than 3) and error is equal to last error, robot is stopped
            if((abs(pidDriveL) < 1) && ((pidLastErrorL == pidErrorL) || (pidErrorL < 3))){
                Brain.Screen.printAt(10, 150, "LDone!");
                lDone = true;
                pidReqValueL = 0;
    			pidSpeedL = 0;
            }

            if((abs(pidDriveR) < 1) && ((pidLastErrorR == pidErrorR) || (pidErrorR < 3))){
                Brain.Screen.printAt(10, 170, "RDone!");
                rDone = true;
                pidReqValueR = 0;
    			pidSpeedR = 0;
            }

            //if both sides are done, stop pid
            if(rDone && lDone){
            	stopPid();
            }
/*
            //before sending to drive motors, correct for straight driving

            if((pidReqValueL == pidReqValueR) && (pidSpeedL == pidSpeedR)){

            if(sideErrorRunning){
            sideError = abs(leftAvg()) - abs(rightAvg());
            //if positive, turning right
            if(sideError > 0){
            	//slow down side going too fast
            //	pidDriveL -= (sideError * pid_sKp);
            	//Brain.Screen.printAt(10, 75, "left");

            }
            //if negative, turning left
            else if(sideError < 0){

            	//Brain.Screen.printAt(10, 95, "right");
            	//slow down side going too fast
            	//pidDriveR -= ( -1 * sideError * pid_sKp);
            }
        	} 

        }
        */
            //send to drive motors - values already scaled to speed
            FrontLeft.spin(vex::directionType::fwd, pidDriveL, vex::velocityUnits::pct);
            BackLeft.spin(vex::directionType::fwd, pidDriveL, vex::velocityUnits::pct);

            FrontRight.spin(vex::directionType::fwd, pidDriveR, vex::velocityUnits::pct);
            BackRight.spin(vex::directionType::fwd, pidDriveR, vex::velocityUnits::pct);
             //debugging with brain screen
             //Brain.Screen.printAt(10, 50, "%d", sideError);

             //speed of drive
             Brain.Screen.printAt(10, 15, "%d", pidDriveL);
             Brain.Screen.printAt(10, 35, "%d", pidDriveR);
             Brain.Screen.printAt(1, 55, "%.6f", leftAvg());
             Brain.Screen.printAt(1, 75, "%.6f", rightAvg());
             Brain.Screen.printAt(1, 105, "%.6f", sideError);
             //Brain.Screen.printAt(1, 125, "%.6f", leftAvg() - rightAvg());

             //error to req value
             //Brain.Screen.printAt(1, 55, "%d", pidErrorL);
             //Brain.Screen.printAt(1, 75, "%d", pidErrorR);

         //   Brain.Screen.printAt(1, 75, "%d", Brain.timer(vex::timeUnits::msec));

             //avg drive values (float)
             //Brain.Screen.printAt(1, 55, "%.6f", ((driveAvg() / 360) * (4 * math_Pi)));
            // Brain.Screen.printAt(1, 75, "%.6f", driveAvg());


             //Brain.Screen.printAt(1, 95, "Init Pid Running!");

             //Brain.Screen.printAt(1, 35, "%.6f", (gScale * Gyro2.value(vex::analogUnits::range8bit)));

        }

        //pid not running
        else {
            // clear all
            pidErrorL      = 0;
            pidLastErrorL  = 0;
            pidIntegralL   = 0;
            pidDerivativeL = 0;
            pidReqValueL   = 0;
            pidSpeedL      = 0;

            pidErrorR      = 0;
            pidLastErrorR  = 0;
            pidIntegralR   = 0;
            pidDerivativeR = 0;
            pidReqValueR   = 0;
            pidSpeedR      = 0;

            sideError = 0;
          //  resetDrive();
            //stop drive
            //FrontLeft.spin(vex::directionType::fwd, 0, vex::velocityUnits::pct);
            //BackLeft.spin(vex::directionType::fwd, 0, vex::velocityUnits::pct);
            //FrontRight.spin(vex::directionType::fwd, 0, vex::velocityUnits::pct);
            //BackRight.spin(vex::directionType::fwd, 0, vex::velocityUnits::pct);

        }

            //to not waste resources
            vex::task::sleep(25);
        }
        return 0;
}


// PID TESTING
    void testingAuto(){
    	 Brain.Screen.clearScreen();

/*
    	float temp = (30 / (4 * math_Pi)) * 360;
        startPid(temp * 0.75, 65 * 0.75, temp, 65);
        vex::task::sleep(300);
        startPid(-1 * temp * 0.75, 65 * 0.75, -1 * temp, 65);
*/

        float temp = (15 / (4 * math_Pi)) * 360;

        startPid(temp, 70, temp, 70);
        vex::task::sleep(300);

       // startPid(-1 * temp, 30, -1 * temp, 30);
        //vex::task::sleep(300);
    }


    //current gyro value holding variable [used in auton]
    int currVal = 0;

    //scaling value for second gyro to match values of first
    //negative cause second gyro is upside down
    float gScale = -1.005;

    //always use 12bit value - it's more precise
    float avgGyro(){
        //avg the two drive sides (scale the second gyro)
        return (((Gyro.value(vex::analogUnits::range12bit)) + (gScale * Gyro2.value(vex::analogUnits::range12bit))) / 2);
    }


void resetOthers(){
    Puncher.resetRotation();
    angleAdjust.resetRotation();
    Scrapper.resetRotation();
    Intake.resetRotation();
}
/*---------------------------------------------------------------------------*/
/*                          Pre-Autonomous Functions                         */
/*                                                                           */
/*  You may want to perform some actions before the competition starts.      */
/*  Do them in the following function.  You must return from this function   */
/*  or the autonomous and usercontrol tasks will not be started.  This       */
/*  function is only called once after the cortex has been powered on and    */ 
/*  not every time that the robot is disabled.                               */
/*---------------------------------------------------------------------------*/

void pre_auton( void ) {

    //reset drive encoders
    resetOthers();
    //reset all other encoders
    resetDrive();
    //calibrate gyro
    Gyro.startCalibration();
    Gyro2.startCalibration();
        //wait until done calibrating
    while(Gyro.isCalibrating() && Gyro2.isCalibrating()){
        Brain.Screen.printAt(1, 40, "Calibrating Gyros . . .");
        vex::task::sleep(100);
    }
    
    //just to make sure gyro is calibrated
    vex::task::sleep(1000);
    Brain.Screen.clearScreen();
    Brain.Screen.printAt(1, 40, "Gyros Calibrated!");
    autoSelect.resetRotation();
}
    void driveCoast(){
      FrontLeft.stop(vex::brakeType::coast);
      BackLeft.stop(vex::brakeType::coast);
      BackRight.stop(vex::brakeType::coast);
      FrontRight.stop(vex::brakeType::coast);

    }
    void driveHold(){
      FrontLeft.stop(vex::brakeType::hold);
      BackLeft.stop(vex::brakeType::hold);
      BackRight.stop(vex::brakeType::hold);
      FrontRight.stop(vex::brakeType::hold);
    }

    void ratchetLoad(){
        if(!pLoaded){
        if(Controller1.ButtonR1.pressing()){
                //wait until released
                   while(Controller1.ButtonR1.pressing()){
                       vex::task::sleep(100);
                   }
                //run func
                pLastVal += 180;
                Puncher.rotateTo(pLastVal, vex::rotationUnits::deg, 100, vex::velocityUnits::pct, true);
                Puncher.setTimeout(1000, vex::timeUnits::msec);
                //Puncher.stop(vex::brakeType::coast);
                pLoaded = true;
                }
            }

    }
    void ratchetFire(){
        if(pLoaded){
        if(Controller1.ButtonR2.pressing()){
                //wait until released
                   while(Controller1.ButtonR2.pressing()){
                       vex::task::sleep(100);
                   }
                //run func
                   pLastVal += 180;
                Puncher.rotateTo(pLastVal, vex::rotationUnits::deg, 100, vex::velocityUnits::pct, true);
                Puncher.setTimeout(1000, vex::timeUnits::msec);

                //Puncher.rotateTo(180, vex::rotationUnits::deg, 100, vex::velocityUnits::pct, true);

                //Puncher.stop(vex::brakeType::coast);
                pLoaded = false;
                }
            }

    }

    void ratchetBoth(){
        if(Controller1.ButtonR1.pressing()){
                //wait until released
                   while(Controller1.ButtonR1.pressing()){
                       vex::task::sleep(100);
                   }
                //run func
                   if(pLoaded){
                   pLastVal += 180;
                Puncher.rotateTo(pLastVal, vex::rotationUnits::deg, 100, vex::velocityUnits::pct, true);
                //Puncher.stop(vex::brakeType::coast);
                pLoaded = false;
                }
                else if(!pLoaded){
                    pLastVal += 180;
                Puncher.rotateTo(pLastVal, vex::rotationUnits::deg, 100, vex::velocityUnits::pct, true);
                //Puncher.stop(vex::brakeType::coast);
                pLoaded = true;
                }
           }
    }

    void ratchetFull(){
        if(Controller1.ButtonR2.pressing()){
                //wait until released
                   while(Controller1.ButtonR2.pressing()){
                       vex::task::sleep(100);
                   }
                //run func
                pLastVal += 360;
                Puncher.rotateTo(pLastVal, vex::rotationUnits::deg, 100, vex::velocityUnits::pct, true);
           }
    }



void ratchetTaskFunc(){
    if(!autoRunning){
    Puncher.stop(vex::brakeType::coast);
    }

    ratchetBoth();
    ratchetFull();
    //ratchetLoad();
    //ratchetFire();
}

    
//other task used to run puncher and cap intake triggers
    
int ratchetTask(){
     while(true){
            ratchetTaskFunc();
            //to not waste resources
            vex::task::sleep(20);
        }
        return 0;
}

    //gyro turn func
    //bool rightTurn - is it a right turn or not
    //vLeft - velocity of left side of drive
    //vRight - velocity of right side of drive
    //amt - amount to turn
    void gyroTurn(bool rightTurn, int vLeft, int vRight, int amt){
        
        //steal the gyro's current value
        currVal = Gyro.value(vex::analogUnits::range8bit);
        
        //if it's a right turn, execute right turn procedure
        if(rightTurn){
          FrontLeft.spin(vex::directionType::fwd, vLeft, vex::velocityUnits::pct);
          BackLeft.spin(vex::directionType::fwd, vLeft, vex::velocityUnits::pct);
          BackRight.spin(vex::directionType::rev, vRight, vex::velocityUnits::pct);
          FrontRight.spin(vex::directionType::rev, vRight, vex::velocityUnits::pct);
          //wait until difference between real time value and stored value passes threshold
          while(((Gyro.value(vex::analogUnits::range8bit)) - currVal) < amt){
            vex::task::sleep(10); 
          }
          driveHold();
          vex::task::sleep(250);
          driveCoast();
        }
        //if it's a left turn, execute left turn
        else if(!rightTurn){
          FrontLeft.spin(vex::directionType::rev, vLeft, vex::velocityUnits::pct);
          BackLeft.spin(vex::directionType::rev, vLeft, vex::velocityUnits::pct);
          BackRight.spin(vex::directionType::fwd, vRight, vex::velocityUnits::pct);
          FrontRight.spin(vex::directionType::fwd, vRight, vex::velocityUnits::pct);
          while(((Gyro.value(vex::analogUnits::range8bit)) - currVal) > (-1 * amt)){
            vex::task::sleep(10); 
          }
          driveHold();
          vex::task::sleep(250);
          driveCoast();
        }
      }
    
    //function to toggle lock and coast with boolean
    void driveLock(bool z){
        // if z is true, lock is turned on
        // else, it's turned off
        if(z){
            driveHold(); 
        }
        else if(!z) {
            driveCoast();
        }
    }

    //d in inches
    //s speed - in pct out of %100
    void driveMoveFor(float d, int s){
        resetDrive();
        driveLock(false);
        //calculate distance from inches to revolutions
        float revo = d / (4 * math_Pi);
        FrontLeft.rotateFor(revo, vex::rotationUnits::rev, s, vex::velocityUnits::pct, false);
        FrontRight.rotateFor(revo, vex::rotationUnits::rev, s, vex::velocityUnits::pct, false);
        BackLeft.rotateFor(revo, vex::rotationUnits::rev, s, vex::velocityUnits::pct, false);
        BackRight.rotateFor(revo, vex::rotationUnits::rev, s, vex::velocityUnits::pct, true);
        //driveLock(true);
    }
    
  //turning without gyro - swing turns
    //left dist in inches - negative for backwards
    //right dist in inches
    //left speed in pct
    //right speed in pct
    void driveTurnFor(float leftdist, float rightddist, int leftSpeed, int rightSpeed){
        resetDrive();
        driveLock(true);
        float Lrevo = leftdist / (4 * math_Pi);
        float Rrevo = rightddist / (4 * math_Pi);
        FrontLeft.rotateFor(Lrevo, vex::rotationUnits::rev, leftSpeed, vex::velocityUnits::pct, false);
        BackLeft.rotateFor(Lrevo, vex::rotationUnits::rev, leftSpeed, vex::velocityUnits::pct, false);
        FrontRight.rotateFor(Rrevo, vex::rotationUnits::rev, rightSpeed, vex::velocityUnits::pct, false);
        BackRight.rotateFor(Rrevo, vex::rotationUnits::rev, rightSpeed, vex::velocityUnits::pct, true);
        driveLock(true);
    }

    //timeout drive for time
    void driveTimeout(float leftTime, float rightTime){
        FrontLeft.setTimeout(leftTime, vex::timeUnits::sec);
        BackLeft.setTimeout(leftTime, vex::timeUnits::sec);
        FrontRight.setTimeout(rightTime, vex::timeUnits::sec);
        BackRight.setTimeout(rightTime, vex::timeUnits::sec);
    }




   

        /*-------------------------------------------------------------------------------------------*/
        /*                                                                                           */
        /*                                                                                           */
        /*  Red Auton .                                                                              */
        /*                                                                                           */
        /*                                                                                           */
        /*-------------------------------------------------------------------------------------------*/

    //if all false, run 3 flag with cap flip
    //if four flag, run 3 flag with cap flip and middle pole low flag
    //if five flag, run 3 flag with cap flip, high flag shot, and middle pole low flag
    //if park, run 3 flag with cap flip and park

    /*
    void threeFlagRed(bool fourFlag, bool fiveFlag, bool park){
         Puncher.resetRotation();
        //reset driveTrain encoders
        resetDrive();
        resetOthers();
        //start intake
        Intake.spin(vex::directionType::fwd, (maxSpeed * .4), vex::velocityUnits::pct);

        //run drive forward for 34 inches
        driveMoveFor(36, 60);
        //wait to intake ball
        vex::task::sleep(150); 

        //slow intake down so ball doesn't get yeet
        Intake.spin(vex::directionType::fwd, (maxSpeed * .5), vex::velocityUnits::pct);
                
        resetDrive();
        //lift up so it doesn't hit field wall
        Lift.rotateTo(340, vex::rotationUnits::deg, 85, vex::velocityUnits::pct, false);
        Lift.setTimeout(1000, vex::timeUnits::msec);

        //hit field wall and realign with swing turn
        //driveTurnFor(-46, -46.5, 80, 75);
        driveTurnFor(-36.2, -36.2, 80, 80);
        resetDrive();
        Intake.spin(vex::directionType::fwd, (maxSpeed * 0), vex::velocityUnits::pct);
        driveMoveFor(-9.5, 45);
        driveTimeout(0.5, 0.5);

        //hold lift up
        Lift.stop(vex::brakeType::hold);

        //settle down
        vex::task::sleep(150);

        resetDrive();

        //stop intake

        //preLoad puncher with ratchet
        Puncher.rotateTo(180, vex::rotationUnits::deg, 100, vex::velocityUnits::pct, false);
        Puncher.setTimeout(600, vex::timeUnits::msec);


        //angle-adjust for high flag
        angleAdjust.rotateTo(42, vex::rotationUnits::deg,100,vex::velocityUnits::pct, false);
        angleAdjust.setTimeout(600, vex::timeUnits::msec);

        //drive forward for flag alignment before turning
        //less driving for new strat
        //driveMoveFor(8.75, 45);
        driveMoveFor(6, 40);
        driveTimeout(1, 1);

        //put ball down
        Intake.rotateFor(-2, vex::rotationUnits::rev, (maxSpeed), vex::velocityUnits::pct, false);
        Intake.setTimeout(1000, vex::timeUnits::msec);

        //put lift down
        
        //using gyro turn left to align with flags

        //start drive motors
        //currVal = Gyro.value(vex::analogUnits::range12bit);

        //take the current avg gyro value with both gyros (:
        currVal = avgGyro();
        FrontLeft.spin(vex::directionType::rev, 40, vex::velocityUnits::pct);
        BackLeft.spin(vex::directionType::rev, 40, vex::velocityUnits::pct);
        BackRight.spin(vex::directionType::fwd, 40, vex::velocityUnits::pct);
        FrontRight.spin(vex::directionType::fwd, 40, vex::velocityUnits::pct);

        //less turning with new strat -old: 890
        //while(((Gyro.value(vex::analogUnits::range12bit)) - currVal) > -825){
          // vex::task::sleep(10); 
       // }
        while(((avgGyro() - currVal) > -825)){
           vex::task::sleep(10); 
        }
        //stop motors with PID
        driveHold();
        driveTimeout(2, 2); 
        //stop motors and put them on coast
        vex::task::sleep(150);
        driveCoast();


        ////drive forward to align front and back for top flag - puncher has already started
        //drive forward to align front and back for top flag - puncher has already preloaded

        //no driving cause angle-adjusting
        //driveMoveFor(8, 50);
        //driveTimeout(1, 1); 

        //pull back slipgear just enough to shoot
        

        Puncher.rotateTo(360, vex::rotationUnits::deg, 100, vex::velocityUnits::pct, true);
        Puncher.setTimeout(1000, vex::timeUnits::msec);
        Puncher.stop(vex::brakeType::coast);

        //get next ball up
        Intake.rotateFor(5, vex::rotationUnits::rev, (maxSpeed * .80), vex::velocityUnits::pct, false);
        vex::task::sleep(100);
        //change angle
        angleAdjust.rotateTo(135, vex::rotationUnits::deg,100,vex::velocityUnits::pct, false);
        angleAdjust.setTimeout(600, vex::timeUnits::msec);
        //give ball a little bit of time
        vex::task::sleep(100);

        //shoot second ball
        Puncher.rotateTo(720, vex::rotationUnits::deg, 100, vex::velocityUnits::pct, true);
        Puncher.setTimeout(1000, vex::timeUnits::msec);
        Puncher.stop(vex::brakeType::coast);

       // vex::task::sleep(2000);

        angleAdjust.rotateTo(0,vex::rotationUnits::deg,100,vex::velocityUnits::pct, false);
        angleAdjust.setTimeout(600, vex::timeUnits::msec);
        //vex::task::sleep(100);
        Intake.spin(vex::directionType::fwd, (maxSpeed), vex::velocityUnits::pct);


        //run intake to get next ball

        //drive forward to next position for medium flag
        //driveMoveFor(21, 65); 
        
        driveCoast();
        resetDrive();

        //gyroTurn(false, 40, 40, 2);
        vex::task::sleep(500);
        FrontLeft.spin(vex::directionType::rev, 10, vex::velocityUnits::pct);
        BackLeft.spin(vex::directionType::rev, 10, vex::velocityUnits::pct);
        BackRight.spin(vex::directionType::fwd, 10, vex::velocityUnits::pct);
        FrontRight.spin(vex::directionType::fwd, 10, vex::velocityUnits::pct);
        //currVal = Gyro.value(vex::analogUnits::range12bit);
        currVal = avgGyro();
        //use last currVal to turn based on last value
        while((avgGyro() - currVal) > -30){
           vex::task::sleep(10); 
        }
        //stop motors with PID
        driveHold();
        driveTimeout(2, 2); 
        //stop motors and put them on coast
        vex::task::sleep(400);
        driveCoast();
        
        resetDrive();
        vex::task::sleep(100);

        Lift.rotateTo(0, vex::rotationUnits::deg, 85, vex::velocityUnits::pct, false);
        Lift.setTimeout(1000, vex::timeUnits::msec);
        Lift.stop(vex::brakeType::coast);
        //rush low flag
        //driveMoveFor(46, 90);
        //driveMoveFor(23, 70);
        driveTurnFor(46, 46, 90, 86);

        
        //driveTurnFor(120, 118, 70, 69);
        vex::task::sleep(50);
        //gyroTurn(true, 30, 30, 4);
        //gyroTurn(true, 40, 40, 2);
        //driveMoveFor(22, 75);

        //vex::task::sleep(2000);
         ///trevo = (75 / (4 * math_Pi));
        
      //  BackRight.rotateFor(trevo, vex::rotationUnits::rev, 45, vex::velocityUnits::pct, false);
      //  BackLeft.rotateFor(trevo, vex::rotationUnits::rev, 45, vex::velocityUnits::pct, true);
        //vex::task::sleep(5000);
        //driveTurnFor(-48, -46.5, 88, 95);
        
        
     //   Puncher.stop(vex::brakeType::coast);

        //drive back before turning to flip cap
        driveMoveFor(-18, 65);
        //reset lift to orig position [just in case]
       // CapIntake.rotateTo(0,vex::rotationUnits::deg, 80,vex::velocityUnits::pct, false);
       // Lift.rotateTo(0, vex::rotationUnits::deg, 85,vex::velocityUnits::pct);
            
        
        //Puncher.rotateFor(150, vex::rotationUnits::deg, 100, vex::velocityUnits::pct, false);
        //turn to face towards low cap
        gyroTurn(true, 50, 50, 68);

        //start intake running backwards to flip cap
        Intake.spin(vex::directionType::rev, (maxSpeed * 0.5), vex::velocityUnits::pct);
        //void threeFlagRed(bool fourFlag, bool fiveFlag, bool park){

        if(park){
          //drive and flip cap
            driveMoveFor(33, 50);
            driveTimeout(1.5, 1.5);

        }
        else if(fourFlag){
          //drive forward to flip cap and drive enough for next shot
            Puncher.rotateTo(900, vex::rotationUnits::deg, 100, vex::velocityUnits::pct, false);
            Puncher.setTimeout(600, vex::timeUnits::msec);
          driveMoveFor(33, 70);
          driveTimeout(1.5, 1.5);
          //vex::task::sleep(100);
          resetDrive();

            angleAdjust.rotateTo(120,vex::rotationUnits::deg,100,vex::velocityUnits::pct, false);
            angleAdjust.setTimeout(600, vex::timeUnits::msec);

           FrontLeft.spin(vex::directionType::rev, 70, vex::velocityUnits::pct);
            BackLeft.spin(vex::directionType::rev, 70, vex::velocityUnits::pct);
            BackRight.spin(vex::directionType::fwd, 70, vex::velocityUnits::pct);
            FrontRight.spin(vex::directionType::fwd, 70, vex::velocityUnits::pct);
            //currVal = Gyro.value(vex::analogUnits::range12bit);
              currVal = avgGyro();
        while((avgGyro() - currVal) > -615){
           vex::task::sleep(10); 
        }
        //stop motors with PID
        driveHold();
        driveTimeout(2, 2); 
        //stop motors and put them on coast
        vex::task::sleep(100);
        driveCoast();



        Puncher.rotateTo(1080, vex::rotationUnits::deg, 100, vex::velocityUnits::pct, true);
        angleAdjust.rotateTo(0,vex::rotationUnits::deg,100,vex::velocityUnits::pct, false);
        angleAdjust.setTimeout(600, vex::timeUnits::msec);
        vex::task::sleep(150);

        driveCoast();

        }
        else if(fiveFlag){

            Puncher.rotateTo(900, vex::rotationUnits::deg, 100, vex::velocityUnits::pct, false);
            Puncher.setTimeout(600, vex::timeUnits::msec);
          driveMoveFor(33, 70);
          driveTimeout(1.5, 1.5);
          //vex::task::sleep(100);
          resetDrive();

            angleAdjust.rotateTo(120,vex::rotationUnits::deg,100,vex::velocityUnits::pct, false);
            angleAdjust.setTimeout(600, vex::timeUnits::msec);

           FrontLeft.spin(vex::directionType::rev, 70, vex::velocityUnits::pct);
            BackLeft.spin(vex::directionType::rev, 70, vex::velocityUnits::pct);
            BackRight.spin(vex::directionType::fwd, 70, vex::velocityUnits::pct);
            FrontRight.spin(vex::directionType::fwd, 70, vex::velocityUnits::pct);
            currVal = avgGyro();

        while(((avgGyro() - currVal)) > -615){
           vex::task::sleep(10); 
        }
        //stop motors with PID
        driveHold();
        driveTimeout(2, 2); 
        //stop motors and put them on coast
        vex::task::sleep(100);
        driveCoast();



        Puncher.rotateTo(1080, vex::rotationUnits::deg, 100, vex::velocityUnits::pct, true);
        angleAdjust.rotateTo(0,vex::rotationUnits::deg,100,vex::velocityUnits::pct, false);
        angleAdjust.setTimeout(600, vex::timeUnits::msec);
        vex::task::sleep(150);

        driveTurnFor(25, 30, 80, 100);

        driveCoast();

           // Lift.setTimeout(600, vex::timeUnits::msec);
            
            //vex::task::sleep(2000);
            //driveMoveFor(-100, 100);
            // Lift.rotateTo(0, vex::rotationUnits::deg, 85, vex::velocityUnits::pct, true);

        }
        //none
        else {
          driveMoveFor(33, 100);
         driveTimeout(1.5, 1.5);
        }

        //end of auton stuff
        Puncher.stop(vex::brakeType::coast);
        Intake.stop(vex::brakeType::coast);
        driveLock(false);
    }

        /*-------------------------------------------------------------------------------------------*/
        /*                                                                                           */
        /*                                                                                           */
        /*  Blue Auton                                                                               */
        /*                                                                                           */
        /*                                                                                           */
        /*-------------------------------------------------------------------------------------------*/
/*
    //same as threeFlagRed, but blue
    //if all false, run 3 flag with cap flip
    //if four flag, run 3 flag with cap flip and middle pole low flag
    //if five flag, run 3 flag with cap flip, high flag shot, and middle pole low flag
    //if park, run 3 flag with cap flip and park
    void threeFlagBlue(bool fourFlag, bool fiveFlag, bool park){
        Puncher.resetRotation();
        //reset driveTrain encoders
        resetDrive();
        resetOthers();
        //start intake
        Intake.spin(vex::directionType::fwd, (maxSpeed * .4), vex::velocityUnits::pct);

        //run drive forward for 34 inches
        driveMoveFor(36, 60);
        //wait to intake ball
        vex::task::sleep(150); 

        //slow intake down so ball doesn't get yeet
        Intake.spin(vex::directionType::fwd, (maxSpeed * .5), vex::velocityUnits::pct);
                
        resetDrive();
        //lift up so it doesn't hit field wall
        Lift.rotateTo(340, vex::rotationUnits::deg, 85, vex::velocityUnits::pct, false);
        Lift.setTimeout(1000, vex::timeUnits::msec);

        //hit field wall and realign with swing turn
        //driveTurnFor(-46, -46.5, 80, 75);
        driveTurnFor(-36.2, -36.2, 80, 80);
        resetDrive();
        Intake.spin(vex::directionType::fwd, (maxSpeed * 0), vex::velocityUnits::pct);
        driveMoveFor(-9.5, 45);
        driveTimeout(0.5, 0.5);

        //hold lift up
        Lift.stop(vex::brakeType::hold);

        //settle down
        vex::task::sleep(150);

        resetDrive();

        //stop intake

        //preLoad puncher with ratchet
        Puncher.rotateTo(180, vex::rotationUnits::deg, 100, vex::velocityUnits::pct, false);
        Puncher.setTimeout(600, vex::timeUnits::msec);


        //angle-adjust for high flag
        angleAdjust.rotateTo(42, vex::rotationUnits::deg,100,vex::velocityUnits::pct, false);
        angleAdjust.setTimeout(600, vex::timeUnits::msec);

        //drive forward for flag alignment before turning
        //less driving for new strat
        //driveMoveFor(8.75, 45);
        driveMoveFor(6, 40);
        driveTimeout(1, 1);

        //put ball down
        Intake.rotateFor(-2, vex::rotationUnits::rev, (maxSpeed), vex::velocityUnits::pct, false);
        Intake.setTimeout(1000, vex::timeUnits::msec);

        //put lift down
        
        //using gyro turn left to align with flags

        //start drive motors
        //currVal = Gyro.value(vex::analogUnits::range12bit);
        currVal = avgGyro();
        FrontLeft.spin(vex::directionType::fwd, 40, vex::velocityUnits::pct);
        BackLeft.spin(vex::directionType::fwd, 40, vex::velocityUnits::pct);
        BackRight.spin(vex::directionType::rev, 40, vex::velocityUnits::pct);
        FrontRight.spin(vex::directionType::rev, 40, vex::velocityUnits::pct);

        //less turning with new strat -old: 890
        while(((avgGyro()) - currVal) < 845){
           vex::task::sleep(10); 
        }
        //stop motors with PID
        driveHold();
        driveTimeout(2, 2); 
        //stop motors and put them on coast
        vex::task::sleep(150);
        driveCoast();


        ////drive forward to align front and back for top flag - puncher has already started
        //drive forward to align front and back for top flag - puncher has already preloaded

        //no driving cause angle-adjusting
        //driveMoveFor(8, 50);
        //driveTimeout(1, 1); 

        //pull back slipgear just enough to shoot
        

        Puncher.rotateTo(360, vex::rotationUnits::deg, 100, vex::velocityUnits::pct, true);
        Puncher.setTimeout(1000, vex::timeUnits::msec);
        Puncher.stop(vex::brakeType::coast);

        //get next ball up
        Intake.rotateFor(5, vex::rotationUnits::rev, (maxSpeed * .80), vex::velocityUnits::pct, false);
        vex::task::sleep(100);
        //change angle
        angleAdjust.rotateTo(135, vex::rotationUnits::deg,100,vex::velocityUnits::pct, false);
        angleAdjust.setTimeout(600, vex::timeUnits::msec);
        //give ball a little bit of time
        vex::task::sleep(100);

        //shoot second ball
        Puncher.rotateTo(720, vex::rotationUnits::deg, 100, vex::velocityUnits::pct, true);
        Puncher.setTimeout(1000, vex::timeUnits::msec);
        Puncher.stop(vex::brakeType::coast);

       // vex::task::sleep(2000);

        angleAdjust.rotateTo(0,vex::rotationUnits::deg,100,vex::velocityUnits::pct, false);
        angleAdjust.setTimeout(600, vex::timeUnits::msec);
        //vex::task::sleep(100);
        Intake.spin(vex::directionType::fwd, (maxSpeed * 0.7), vex::velocityUnits::pct);


        //run intake to get next ball

        //drive forward to next position for medium flag
        //driveMoveFor(21, 65); 
        
        driveCoast();
        resetDrive();

        //gyroTurn(false, 40, 40, 2);
        vex::task::sleep(500);
        FrontLeft.spin(vex::directionType::fwd, 10, vex::velocityUnits::pct);
        BackLeft.spin(vex::directionType::fwd, 10, vex::velocityUnits::pct);
        BackRight.spin(vex::directionType::rev, 10, vex::velocityUnits::pct);
        FrontRight.spin(vex::directionType::rev, 10, vex::velocityUnits::pct);
        //currVal = Gyro.value(vex::analogUnits::range12bit);
        currVal = avgGyro();
        //use last currVal to turn based on last value
        while(((avgGyro()) - currVal) < 30){
           vex::task::sleep(10); 
        }
        //stop motors with PID
        driveHold();
        driveTimeout(2, 2); 
        //stop motors and put them on coast
        vex::task::sleep(400);
        driveCoast();
        
        resetDrive();
        vex::task::sleep(100);

        Lift.rotateTo(0, vex::rotationUnits::deg, 85, vex::velocityUnits::pct, false);
        Lift.setTimeout(1000, vex::timeUnits::msec);
        Lift.stop(vex::brakeType::coast);
        //rush low flag
        driveMoveFor(46, 90);
        //driveMoveFor(23, 70);
        //driveTurnFor(21, 23, 63, 70);

        
        //driveTurnFor(120, 118, 70, 69);
        vex::task::sleep(50);
        //gyroTurn(true, 30, 30, 4);
        //gyroTurn(true, 40, 40, 2);
        //driveMoveFor(22, 75);

        //vex::task::sleep(2000);
         ///trevo = (75 / (4 * math_Pi));
        
      //  BackRight.rotateFor(trevo, vex::rotationUnits::rev, 45, vex::velocityUnits::pct, false);
      //  BackLeft.rotateFor(trevo, vex::rotationUnits::rev, 45, vex::velocityUnits::pct, true);
        //vex::task::sleep(5000);
        //driveTurnFor(-48, -46.5, 88, 95);
        
        
     //   Puncher.stop(vex::brakeType::coast);

        //drive back before turning to flip cap
        driveMoveFor(-18, 65);
        //reset lift to orig position [just in case]
       // CapIntake.rotateTo(0,vex::rotationUnits::deg, 80,vex::velocityUnits::pct, false);
       // Lift.rotateTo(0, vex::rotationUnits::deg, 85,vex::velocityUnits::pct);
            
        
        //Puncher.rotateFor(150, vex::rotationUnits::deg, 100, vex::velocityUnits::pct, false);
        //turn to face towards low cap
        gyroTurn(false, 50, 50, 63);

        //start intake running backwards to flip cap
        Intake.spin(vex::directionType::rev, (maxSpeed * 0.35), vex::velocityUnits::pct);
        //void threeFlagRed(bool fourFlag, bool fiveFlag, bool park){

        if(park){
          //drive and flip cap
            driveMoveFor(33, 50);
            driveTimeout(1.5, 1.5);

        }
        else if(fourFlag){
          //drive forward to flip cap and drive enough for next shot
            Puncher.rotateTo(900, vex::rotationUnits::deg, 100, vex::velocityUnits::pct, false);
            Puncher.setTimeout(600, vex::timeUnits::msec);
          driveMoveFor(33, 70);
          driveTimeout(1.5, 1.5);
          //vex::task::sleep(100);
          resetDrive();

            angleAdjust.rotateTo(120,vex::rotationUnits::deg,100,vex::velocityUnits::pct, false);
            angleAdjust.setTimeout(600, vex::timeUnits::msec);

           FrontLeft.spin(vex::directionType::fwd, 70, vex::velocityUnits::pct);
            BackLeft.spin(vex::directionType::fwd, 70, vex::velocityUnits::pct);
            BackRight.spin(vex::directionType::rev, 70, vex::velocityUnits::pct);
            FrontRight.spin(vex::directionType::rev, 70, vex::velocityUnits::pct);
            //currVal = Gyro.value(vex::analogUnits::range12bit);
            currVal = avgGyro();

        while(((avgGyro()) - currVal) < 630){
           vex::task::sleep(10); 
        }
        //stop motors with PID
        driveHold();
        driveTimeout(2, 2); 
        //stop motors and put them on coast
        vex::task::sleep(100);
        driveCoast();



        Puncher.rotateTo(1080, vex::rotationUnits::deg, 100, vex::velocityUnits::pct, true);
        angleAdjust.rotateTo(0,vex::rotationUnits::deg,100,vex::velocityUnits::pct, false);
        angleAdjust.setTimeout(600, vex::timeUnits::msec);
        vex::task::sleep(150);

        driveCoast();

        }
        else if(fiveFlag){

            Puncher.rotateTo(900, vex::rotationUnits::deg, 100, vex::velocityUnits::pct, false);
            Puncher.setTimeout(600, vex::timeUnits::msec);
          driveMoveFor(33, 70);
          driveTimeout(1.5, 1.5);
          //vex::task::sleep(100);
          resetDrive();

            angleAdjust.rotateTo(120,vex::rotationUnits::deg,100,vex::velocityUnits::pct, false);
            angleAdjust.setTimeout(600, vex::timeUnits::msec);

           FrontLeft.spin(vex::directionType::fwd, 70, vex::velocityUnits::pct);
            BackLeft.spin(vex::directionType::fwd, 70, vex::velocityUnits::pct);
            BackRight.spin(vex::directionType::rev, 70, vex::velocityUnits::pct);
            FrontRight.spin(vex::directionType::rev, 70, vex::velocityUnits::pct);
            //currVal = Gyro.value(vex::analogUnits::range12bit);
            currVal = avgGyro();
        while(((avgGyro()) - currVal) < 600){
           vex::task::sleep(10); 
        }
        //stop motors with PID
        driveHold();
        driveTimeout(2, 2); 
        //stop motors and put them on coast
        vex::task::sleep(100);
        driveCoast();



        Puncher.rotateTo(1080, vex::rotationUnits::deg, 100, vex::velocityUnits::pct, true);
        angleAdjust.rotateTo(0,vex::rotationUnits::deg,100,vex::velocityUnits::pct, false);
        angleAdjust.setTimeout(600, vex::timeUnits::msec);
        vex::task::sleep(150);

        driveTurnFor(30, 25, 100, 80);

        driveCoast();

           // Lift.setTimeout(600, vex::timeUnits::msec);
            
            //vex::task::sleep(2000);
            //driveMoveFor(-100, 100);
            // Lift.rotateTo(0, vex::rotationUnits::deg, 85, vex::velocityUnits::pct, true);

        }
        //none
        else {
          driveMoveFor(33, 100);
         driveTimeout(1.5, 1.5);
        }

        //end of auton stuff
        Puncher.stop(vex::brakeType::coast);
        Intake.stop(vex::brakeType::coast);
        driveLock(false);
    }

    void redParking(){
        resetDrive();
        resetOthers();

        //drive forward
        driveMoveFor(36, 50);
        vex ::task::sleep(300);


        resetDrive();

        //turn and face platform
        FrontLeft.spin(vex::directionType::fwd, 40, vex::velocityUnits::pct);
        BackLeft.spin(vex::directionType::fwd, 40, vex::velocityUnits::pct);
        BackRight.spin(vex::directionType::rev, 40, vex::velocityUnits::pct);
        FrontRight.spin(vex::directionType::rev, 40, vex::velocityUnits::pct);
        currVal = Gyro.value(vex::analogUnits::range12bit);

        while(((Gyro.value(vex::analogUnits::range12bit)) - currVal) < 860){
           vex::task::sleep(5); 
        }
        //stop motors with PID
        driveHold();
        driveTimeout(2, 2); 
        //stop motors and put them on coast
        vex::task::sleep(300);
        driveCoast();
        vex::task::sleep(300);
        resetDrive();
        //drive up platform
        driveMoveFor(55, 100);
        vex::task::sleep(300);
        resetDrive();

    }

    void blueParking(){
       resetDrive();
        resetOthers();
        //drive forward
        driveMoveFor(36, 50);
        vex ::task::sleep(300);


        resetDrive();

        //turn and face platform
        FrontLeft.spin(vex::directionType::rev, 60, vex::velocityUnits::pct);
        BackLeft.spin(vex::directionType::rev, 60, vex::velocityUnits::pct);
        BackRight.spin(vex::directionType::fwd, 60, vex::velocityUnits::pct);
        FrontRight.spin(vex::directionType::fwd, 60, vex::velocityUnits::pct);
        currVal = Gyro.value(vex::analogUnits::range12bit);

        while(((Gyro.value(vex::analogUnits::range12bit)) - currVal) > -920){
           vex::task::sleep(10); 
        }
        //stop motors with PID
        driveHold();
        driveTimeout(2, 2); 
        //stop motors and put them on coast
        vex::task::sleep(250);
        driveCoast();
        vex::task::sleep(300);
        //drive up platform
        driveMoveFor(55, 100);
        resetDrive();
    }

    void backRedMiddle(){
        resetDrive();
        resetOthers();
        //start intake
        Intake.spin(vex::directionType::fwd, (maxSpeed * 1), vex::velocityUnits::pct);

        //run drive forward for 36 inches
        driveMoveFor(36, 55);
        //wait to intake ball
        vex ::task::sleep(300); 

        //slow intake down so ball doesn't get yeet
        Intake.spin(vex::directionType::fwd, (maxSpeed * 1), vex::velocityUnits::pct);  

        resetDrive();

        //drive back a little
        driveMoveFor(-1.5, 40);

        //now that we have the ball, put it down a little before we shoot
        Intake.rotateFor(-1.5, vex::rotationUnits::rev, (maxSpeed), vex::velocityUnits::pct, false);
        Intake.setTimeout(1000, vex::timeUnits::msec);

        vex ::task::sleep(300); 
        //turn left to face alliance platform
        FrontLeft.spin(vex::directionType::rev, 40, vex::velocityUnits::pct);
        BackLeft.spin(vex::directionType::rev, 40, vex::velocityUnits::pct);
        BackRight.spin(vex::directionType::fwd, 40, vex::velocityUnits::pct);
        FrontRight.spin(vex::directionType::fwd, 40, vex::velocityUnits::pct);
        currVal = Gyro.value(vex::analogUnits::range12bit);

        while(((Gyro.value(vex::analogUnits::range12bit)) - currVal) > -920){
           vex::task::sleep(10); 
        }
        //stop motors with PID
        driveHold();
        driveTimeout(2, 2); 
        //stop motors and put them on coast
        vex::task::sleep(150);
        driveCoast();

        vex::task::sleep(300); 

        //prepull back puncher for shooting later on
        Puncher.rotateTo(180, vex::rotationUnits::deg, 100, vex::velocityUnits::pct, false);
        Puncher.setTimeout(600, vex::timeUnits::msec);

        //angle adjust ahead of time for first shot
        angleAdjust.rotateTo(60, vex::rotationUnits::deg, 100,vex::velocityUnits::pct, false);
        angleAdjust.setTimeout(600, vex::timeUnits::msec);

        //drive forward to align against low platform
        driveMoveFor(5, 40);

        vex::task::sleep(300); 

        //move right side backwards to slowly align with flags
        BackRight.spin(vex::directionType::rev, 25, vex::velocityUnits::pct);
        FrontRight.spin(vex::directionType::rev, 25, vex::velocityUnits::pct);
        currVal = Gyro.value(vex::analogUnits::range12bit);

        while(((Gyro.value(vex::analogUnits::range12bit)) - currVal) < 75){
           vex::task::sleep(10); 
        }
        //stop motors with PID
        driveHold();
        driveTimeout(2, 2); 
        //stop motors and put them on coast
        vex::task::sleep(300);
        driveCoast();

        //aligned, so shoot both flags

        //first shot would be too high, but we're already angle adjusted
        Puncher.rotateTo(360, vex::rotationUnits::deg, 100, vex::velocityUnits::pct, true);
        Puncher.setTimeout(1000, vex::timeUnits::msec);
        Puncher.stop(vex::brakeType::coast);

        //next ball up
        Intake.rotateFor(5, vex::rotationUnits::rev, (maxSpeed * .80), vex::velocityUnits::pct, false);
        vex::task::sleep(100);

        //angle adjust to medium height
        angleAdjust.rotateTo(135, vex::rotationUnits::deg,100,vex::velocityUnits::pct, true);
        angleAdjust.setTimeout(600, vex::timeUnits::msec);
        
        vex::task::sleep(100);

        //shoot next shot
        Puncher.rotateTo(720, vex::rotationUnits::deg, 100, vex::velocityUnits::pct, true);
        Puncher.setTimeout(1000, vex::timeUnits::msec);
        Puncher.stop(vex::brakeType::coast);
        vex::task::sleep(100);

        //reset angle-adjuster for start of match
        angleAdjust.rotateTo(0,vex::rotationUnits::deg,100,vex::velocityUnits::pct, false);
        angleAdjust.setTimeout(600, vex::timeUnits::msec);

        //stop intake (just in case)
        Intake.stop(vex::brakeType::coast);
        resetDrive();

        BackRight.spin(vex::directionType::fwd, 40, vex::velocityUnits::pct);
        FrontRight.spin(vex::directionType::fwd, 40, vex::velocityUnits::pct);
        currVal = Gyro.value(vex::analogUnits::range12bit);

        while(((Gyro.value(vex::analogUnits::range12bit)) - currVal) > -75){
           vex::task::sleep(10); 
        }
        //stop motors with PID
        driveHold();
        driveTimeout(2, 2); 
        //stop motors and put them on coast
        vex::task::sleep(150);
        driveCoast();

        //drive back a little before charging up platform
        driveMoveFor(-10, 50);
        vex::task::sleep(300);

        //drive up platform
        driveMoveFor(50, 100);

    }
    void backBlueMiddle(){
        resetDrive();
        resetOthers();
        //start intake
        Intake.spin(vex::directionType::fwd, (maxSpeed * .7), vex::velocityUnits::pct);

        //run drive forward for 36 inches
        driveMoveFor(36, 55);
        //wait to intake ball
        vex ::task::sleep(300); 

        //slow intake down so ball doesn't get yeet
        Intake.spin(vex::directionType::fwd, (maxSpeed * .7), vex::velocityUnits::pct);  

        resetDrive();

        //drive back a little
        driveMoveFor(-6, 40);

        //now that we have the ball, put it down a little before we shoot
        Intake.rotateFor(-2, vex::rotationUnits::rev, (maxSpeed), vex::velocityUnits::pct, false);
        Intake.setTimeout(1000, vex::timeUnits::msec);

        vex ::task::sleep(300); 
        //turn left to face alliance platform
        FrontLeft.spin(vex::directionType::fwd, 40, vex::velocityUnits::pct);
        BackLeft.spin(vex::directionType::fwd, 40, vex::velocityUnits::pct);
        BackRight.spin(vex::directionType::rev, 40, vex::velocityUnits::pct);
        FrontRight.spin(vex::directionType::rev, 40, vex::velocityUnits::pct);
        currVal = Gyro.value(vex::analogUnits::range12bit);

        while(((Gyro.value(vex::analogUnits::range12bit)) - currVal) < 870){
           vex::task::sleep(10); 
        }
        //stop motors with PID
        driveHold();
        driveTimeout(2, 2); 
        //stop motors and put them on coast
        vex::task::sleep(150);
        driveCoast();

        vex::task::sleep(300); 

        //prepull back puncher for shooting later on
        Puncher.rotateTo(180, vex::rotationUnits::deg, 100, vex::velocityUnits::pct, false);
        Puncher.setTimeout(600, vex::timeUnits::msec);

        //angle adjust ahead of time for first shot
        angleAdjust.rotateTo(60, vex::rotationUnits::deg, 100,vex::velocityUnits::pct, false);
        angleAdjust.setTimeout(600, vex::timeUnits::msec);

        //drive forward to align against low platform
        driveMoveFor(5.2, 40);

        vex::task::sleep(300); 

        //move right side backwards to slowly align with flags
        BackLeft.spin(vex::directionType::rev, 25, vex::velocityUnits::pct);
        FrontLeft.spin(vex::directionType::rev, 25, vex::velocityUnits::pct);
        currVal = Gyro.value(vex::analogUnits::range12bit);

        while(((Gyro.value(vex::analogUnits::range12bit)) - currVal) > -75){
           vex::task::sleep(10); 
        }
        //stop motors with PID
        driveHold();
        driveTimeout(2, 2); 
        //stop motors and put them on coast
        vex::task::sleep(300);
        driveCoast();

        //aligned, so shoot both flags

        //first shot would be too high, but we're already angle adjusted
        Puncher.rotateTo(360, vex::rotationUnits::deg, 100, vex::velocityUnits::pct, true);
        Puncher.setTimeout(1000, vex::timeUnits::msec);
        Puncher.stop(vex::brakeType::coast);

        //next ball up
        Intake.rotateFor(5, vex::rotationUnits::rev, (maxSpeed * .80), vex::velocityUnits::pct, false);
        vex::task::sleep(100);

        //angle adjust to medium height
        angleAdjust.rotateTo(135, vex::rotationUnits::deg,100,vex::velocityUnits::pct, true);
        angleAdjust.setTimeout(600, vex::timeUnits::msec);
        
        vex::task::sleep(100);

        //shoot next shot
        Puncher.rotateTo(720, vex::rotationUnits::deg, 100, vex::velocityUnits::pct, true);
        Puncher.setTimeout(1000, vex::timeUnits::msec);
        Puncher.stop(vex::brakeType::coast);
        vex::task::sleep(100);

        //reset angle-adjuster for start of match
        angleAdjust.rotateTo(0,vex::rotationUnits::deg,100,vex::velocityUnits::pct, false);
        angleAdjust.setTimeout(600, vex::timeUnits::msec);

        //stop intake (just in case)
        Intake.stop(vex::brakeType::coast);
        resetDrive();

        BackLeft.spin(vex::directionType::fwd, 40, vex::velocityUnits::pct);
        FrontLeft.spin(vex::directionType::fwd, 40, vex::velocityUnits::pct);
        currVal = Gyro.value(vex::analogUnits::range12bit);

        while(((Gyro.value(vex::analogUnits::range12bit)) - currVal) < 75){
           vex::task::sleep(10); 
        }
        //stop motors with PID
        driveHold();
        driveTimeout(2, 2); 
        //stop motors and put them on coast
        vex::task::sleep(150);
        driveCoast();

        //drive back a little before charging up platform
        driveMoveFor(-10, 50);
        vex::task::sleep(300);

        //drive up platform
        driveMoveFor(51, 100);
        driveLock(true);
        vex::task::sleep(1500);
        driveLock(false);

    }

    //same as middle auto, but shoots cross court to descore other side
    void backRedFar(){
        resetDrive();
        resetOthers();
        //start intake
        Intake.spin(vex::directionType::fwd, (maxSpeed * 1), vex::velocityUnits::pct);

        //run drive forward for 36 inches
        driveMoveFor(36, 55);
        //wait to intake ball
        vex ::task::sleep(300); 

        //slow intake down so ball doesn't get yeet
        Intake.spin(vex::directionType::fwd, (maxSpeed * 1), vex::velocityUnits::pct);  

        resetDrive();

        //drive back a little
        driveMoveFor(-1.5, 40);

        Intake.spin(vex::directionType::fwd, (maxSpeed * 0), vex::velocityUnits::pct);  
        //now that we have the ball, put it down a little before we shoot
        vex ::task::sleep(600); 
        Intake.rotateFor(-2, vex::rotationUnits::rev, (maxSpeed), vex::velocityUnits::pct, false);
        Intake.setTimeout(1000, vex::timeUnits::msec);

        vex ::task::sleep(300); 
        //turn left to face alliance platform
        FrontLeft.spin(vex::directionType::rev, 40, vex::velocityUnits::pct);
        BackLeft.spin(vex::directionType::rev, 40, vex::velocityUnits::pct);
        BackRight.spin(vex::directionType::fwd, 40, vex::velocityUnits::pct);
        FrontRight.spin(vex::directionType::fwd, 40, vex::velocityUnits::pct);
        currVal = Gyro.value(vex::analogUnits::range12bit);

        while(((Gyro.value(vex::analogUnits::range12bit)) - currVal) > -920){
           vex::task::sleep(10); 
        }
        //stop motors with PID
        driveHold();
        driveTimeout(2, 2); 
        //stop motors and put them on coast
        vex::task::sleep(150);
        driveCoast();

        vex::task::sleep(300); 

        //prepull back puncher for shooting later on
        //Puncher.rotateTo(180, vex::rotationUnits::deg, 100, vex::velocityUnits::pct, false);
        //Puncher.setTimeout(600, vex::timeUnits::msec);

        //angle adjust ahead of time for first shot
        angleAdjust.rotateTo(60, vex::rotationUnits::deg, 100,vex::velocityUnits::pct, false);
        angleAdjust.setTimeout(600, vex::timeUnits::msec);

        //drive forward to align against low platform
        driveMoveFor(5, 40);

        vex::task::sleep(300); 

        //move right side backwards to slowly align with flags
        BackRight.spin(vex::directionType::rev, 25, vex::velocityUnits::pct);
        FrontRight.spin(vex::directionType::rev, 25, vex::velocityUnits::pct);
        currVal = Gyro.value(vex::analogUnits::range12bit);

        //testing 400 value
        while(((Gyro.value(vex::analogUnits::range12bit)) - currVal) < 330){
           vex::task::sleep(10); 
        }
        //stop motors with PID
        driveHold();
        driveTimeout(2, 2); 
        //stop motors and put them on coast
        vex::task::sleep(300);
        driveCoast();

        //delay and wait 4 seconds as to shoot flags as late as possible (without delay, 10.5 second auto)
        //adjust to make auto 14.5 seconds
        vex::task::sleep(2600); 

        //aligned, so shoot both flags
        //first shot would be too high, but we're already angle adjusted
        Puncher.rotateTo(360, vex::rotationUnits::deg, 100, vex::velocityUnits::pct, true);
        Puncher.setTimeout(1000, vex::timeUnits::msec);
        Puncher.stop(vex::brakeType::coast);

        //next ball up
        Intake.rotateFor(5, vex::rotationUnits::rev, (maxSpeed * .80), vex::velocityUnits::pct, false);
        vex::task::sleep(100);

        //angle adjust to medium height
        angleAdjust.rotateTo(130, vex::rotationUnits::deg,100,vex::velocityUnits::pct, true);
        angleAdjust.setTimeout(600, vex::timeUnits::msec);
        
        vex::task::sleep(100);

        //shoot next shot
        Puncher.rotateTo(720, vex::rotationUnits::deg, 100, vex::velocityUnits::pct, true);
        Puncher.setTimeout(1000, vex::timeUnits::msec);
        Puncher.stop(vex::brakeType::coast);
        vex::task::sleep(100);

        //reset angle-adjuster for start of match
        angleAdjust.rotateTo(0,vex::rotationUnits::deg,100,vex::velocityUnits::pct, false);
        angleAdjust.setTimeout(600, vex::timeUnits::msec);

        //stop intake (just in case)
        Intake.stop(vex::brakeType::coast);
        resetDrive();

        BackRight.spin(vex::directionType::fwd, 40, vex::velocityUnits::pct);
        FrontRight.spin(vex::directionType::fwd, 40, vex::velocityUnits::pct);
        currVal = Gyro.value(vex::analogUnits::range12bit);

        //tesing 400 value
        while(((Gyro.value(vex::analogUnits::range12bit)) - currVal) > -330){
           vex::task::sleep(10); 
        }
        //stop motors with PID
        driveHold();
        driveTimeout(2, 2); 
        //stop motors and put them on coast
        vex::task::sleep(150);
        driveCoast();

        //drive back a little before charging up platform
        driveMoveFor(-10, 50);
        vex::task::sleep(300);

        //drive up platform
        driveMoveFor(50, 100);
    }

    void backBlueFar(){
        resetDrive();
        resetOthers();
        //start intake
        Intake.spin(vex::directionType::fwd, (maxSpeed * 1), vex::velocityUnits::pct);

        //run drive forward for 36 inches
        driveMoveFor(36, 55);
        //wait to intake ball
        vex ::task::sleep(300); 

        //slow intake down so ball doesn't get yeet
        Intake.spin(vex::directionType::fwd, (maxSpeed * 1), vex::velocityUnits::pct);  

        resetDrive();

        //drive back a little
        driveMoveFor(-6, 40);

        Intake.spin(vex::directionType::fwd, (maxSpeed * 0), vex::velocityUnits::pct);  
        //now that we have the ball, put it down a little before we shoot
        vex ::task::sleep(600); 
        Intake.rotateFor(-2, vex::rotationUnits::rev, (maxSpeed), vex::velocityUnits::pct, false);
        Intake.setTimeout(1000, vex::timeUnits::msec);

        vex ::task::sleep(300); 
        //turn left to face alliance platform
        FrontLeft.spin(vex::directionType::fwd, 40, vex::velocityUnits::pct);
        BackLeft.spin(vex::directionType::fwd, 40, vex::velocityUnits::pct);
        BackRight.spin(vex::directionType::rev, 40, vex::velocityUnits::pct);
        FrontRight.spin(vex::directionType::rev, 40, vex::velocityUnits::pct);
        currVal = Gyro.value(vex::analogUnits::range12bit);

        while(((Gyro.value(vex::analogUnits::range12bit)) - currVal) < 870){
           vex::task::sleep(10); 
        }
        //stop motors with PID
        driveHold();
        driveTimeout(2, 2); 
        //stop motors and put them on coast
        vex::task::sleep(150);
        driveCoast();

        vex::task::sleep(300); 

        //prepull back puncher for shooting later on
        //Puncher.rotateTo(180, vex::rotationUnits::deg, 100, vex::velocityUnits::pct, false);
        //Puncher.setTimeout(600, vex::timeUnits::msec);

        //angle adjust ahead of time for first shot
        angleAdjust.rotateTo(60, vex::rotationUnits::deg, 100,vex::velocityUnits::pct, false);
        angleAdjust.setTimeout(600, vex::timeUnits::msec);

        //drive forward to align against low platform
        driveMoveFor(5.7, 40);

        vex::task::sleep(300); 

        //move right side backwards to slowly align with flags
        BackLeft.spin(vex::directionType::rev, 25, vex::velocityUnits::pct);
        FrontLeft.spin(vex::directionType::rev, 25, vex::velocityUnits::pct);
        currVal = Gyro.value(vex::analogUnits::range12bit);

        //testing 400 value
        while(((Gyro.value(vex::analogUnits::range12bit)) - currVal) > -315){
           vex::task::sleep(10); 
        }
        //stop motors with PID
        driveHold();
        driveTimeout(2, 2); 
        //stop motors and put them on coast
        vex::task::sleep(300);
        driveCoast();

        //delay and wait 4 seconds as to shoot flags as late as possible (without delay, 10.5 second auto)
        //adjust to make auto 14.5 seconds
        vex::task::sleep(2600); 

        //aligned, so shoot both flags
        //first shot would be too high, but we're already angle adjusted
        Puncher.rotateTo(360, vex::rotationUnits::deg, 100, vex::velocityUnits::pct, true);
        Puncher.setTimeout(1000, vex::timeUnits::msec);
        Puncher.stop(vex::brakeType::coast);

        //next ball up
        Intake.rotateFor(5, vex::rotationUnits::rev, (maxSpeed * .80), vex::velocityUnits::pct, false);
        vex::task::sleep(100);

        //angle adjust to medium height
        angleAdjust.rotateTo(130, vex::rotationUnits::deg,100,vex::velocityUnits::pct, true);
        angleAdjust.setTimeout(600, vex::timeUnits::msec);
        
        vex::task::sleep(100);

        //shoot next shot
        Puncher.rotateTo(720, vex::rotationUnits::deg, 100, vex::velocityUnits::pct, true);
        Puncher.setTimeout(1000, vex::timeUnits::msec);
        Puncher.stop(vex::brakeType::coast);
        vex::task::sleep(100);

        //reset angle-adjuster for start of match
        angleAdjust.rotateTo(0,vex::rotationUnits::deg,100,vex::velocityUnits::pct, false);
        angleAdjust.setTimeout(600, vex::timeUnits::msec);

        //stop intake (just in case)
        Intake.stop(vex::brakeType::coast);
        resetDrive();

        BackLeft.spin(vex::directionType::fwd, 40, vex::velocityUnits::pct);
        FrontLeft.spin(vex::directionType::fwd, 40, vex::velocityUnits::pct);
        currVal = Gyro.value(vex::analogUnits::range12bit);

        //tesing 400 value
        while(((Gyro.value(vex::analogUnits::range12bit)) - currVal) < 315){
           vex::task::sleep(10); 
        }
        //stop motors with PID
        driveHold();
        driveTimeout(2, 2); 
        //stop motors and put them on coast
        vex::task::sleep(150);
        driveCoast();

        //drive back a little before charging up platform
        driveMoveFor(-7, 45);
        vex::task::sleep(300);

        //drive up platform
        driveMoveFor(41.5, 100);
    }

    */

void autonomous( void ) {

    //start pid task for auto
    vex::task pidTasks(pidTask);

    //red autos
   
    autoRunning = true;
    testingAuto();
     /*
    //how many "units"
    float tempVal = ((autoSelect.rotation(vex::rotationUnits::deg)) / 90);


    //use autoSelect to choose which auto to run
    if(tempVal < .25){
        //default - 5 flag
        Brain.Screen.printAt(1, 175, "5FlagRed");          
        //threeFlagRed(false, true, false);
    }
    else if(tempVal < 1.25){
        //four flag
        Brain.Screen.printAt(1, 15, "4FlagRed");  
        //threeFlagRed(true, false, false);

    }
    else if(tempVal < 1.25 * 2){
        //middle cross
        Brain.Screen.printAt(1, 15, "RedBackMiddle");  
        //backRedMiddle();
        
        
    }
    else if(tempVal < 1.25 * 3){
        //descore far
        Brain.Screen.printAt(1, 15, "RedBackFar");  
        //backRedFar();
    }
    else if(tempVal < 1.25 * 4){
        //descore far
        Brain.Screen.printAt(1, 15, "Skills Auto");  
        //testingAuto();
    }

    // B L U E  S I D E

    if(tempVal < .25){
        //default - 5 flag
        Brain.Screen.printAt(1, 15, "5FlagBlue");
        threeFlagBlue(false, true, false);

    }
    else if(tempVal < 1.15){
        //four flag
        Brain.Screen.printAt(1, 15, "4FlagBlue");
        threeFlagBlue(true, false, false);

    }
    else if(tempVal < 1.15 * 2){
        //middle cross
        Brain.Screen.printAt(1, 15, "BlueBackMiddle");
        backBlueMiddle();
        
        
    }
    else if(tempVal < 1.15 * 3){
        //descore far
        Brain.Screen.printAt(1, 15, "BlueBackFar");
        backBlueFar();
    }

    */
    
    /*  all false = just 3 flag with cap flip
        if first bool true, 4 flag
        if second bool true, 5 flag
        if third bool true, parking auton
        (bool fourFlag, bool fiveFlag, bool park)
    */
    
    //3 flag function - red side
    //5 flag
      //threeFlagRed(false, true, false);
    //4 flag
      //threeFlagRed(true, false, false);
    //3 flag
      //threeFlagRed(false, false, false);

    //3 flag function - blue side
    //5 flag
      //threeFlagBlue(false, true, false);
    //4 flag
      //threeFlagBlue(true, false, false);
    //3 flag
      //threeFlagBlue(false, false, false);

    //back red park
    //redParking();

    //back blue park
    //blueParking();

        
    //back sides - red
    //backRedMiddle();
    //backRedFar();

    //back sides - blue
    //backBlueMiddle();
    //backBlueFar();

    //stop pid task - only needed for auto
    vex::task::stop(pidTask); 
    //wait 10 seconds
    vex::task::sleep(10000);

}


    void autoAngle(){
        //if puncher trigger is clicked
        //high flags
        if(angleTrigger){
            if(anglePos == 0){
                angleAdjust.rotateTo(0,vex::rotationUnits::deg,100,vex::velocityUnits::pct);
                angleAdjust.setTimeout(600, vex::timeUnits::msec);

                //angleAdjust.stop(vex::brakeType::coast);

            }
            //medium flag
            else if(anglePos == 1){
                angleAdjust.rotateTo(100,vex::rotationUnits::deg,100,vex::velocityUnits::pct);
                angleAdjust.setTimeout(600, vex::timeUnits::msec);


            }
            //lowest flag
            else if(anglePos == 2){
                 angleAdjust.rotateTo(262,vex::rotationUnits::deg,100,vex::velocityUnits::pct);
                 angleAdjust.setTimeout(600, vex::timeUnits::msec);



            }
            angleTrigger = false;
        }
    }
    
    void angleTriggerDetect(){
            //toggle between high and medium
            if(Controller1.ButtonUp.pressing()){
            //wait until released
               while(Controller1.ButtonUp.pressing()){
                   vex::task::sleep(100);
               }
            //run func
               if(anglePos != 2){
            angleTrigger = true;
            anglePos = 1 - anglePos;
        }
            }  

            //lowest flag toggle
            else if(Controller1.ButtonRight.pressing()){
                //wait until released
               while(Controller1.ButtonRight.pressing()){
                   vex::task::sleep(100);
               }
            //run func
            angleTrigger = true;

            anglePos = 2 - anglePos;
            }


            //motor holds
            if(!angleTrigger){
            if(anglePos == 0)
                angleAdjust.stop(vex::brakeType::coast);
            
            //medium flag
            else if(anglePos == 1)
                angleAdjust.stop(vex::brakeType::hold);
            
            //lowest flag
            else if(anglePos == 2)
                 angleAdjust.stop(vex::brakeType::hold);
         }

        }
    

    

    void driveLockDetect(){
        if(Controller1.ButtonLeft.pressing()){
           //wait until released
           while(Controller1.ButtonLeft.pressing()){
               vex::task::sleep(100);
           }
           //run func
            driveLockOn = !driveLockOn;
           driveLock(driveLockOn);
       }
    }

  
    void scrapperMedium(){
        if(Controller1.ButtonY.pressing()){
        	scrapperEnabled = true;
                //wait until released
                   while(Controller1.ButtonY.pressing()){
                       vex::task::sleep(100);
                   }

                //if scrapper is in (false)
                if(!scrapperPos){
                	Scrapper.rotateTo(-150, vex::rotationUnits::deg, 100, vex::velocityUnits::pct, true);
                	Scrapper.setTimeout(750, vex::timeUnits::msec);
                }
                //if scrapper is out (true)
                else if(scrapperPos){
                	Scrapper.rotateTo(0, vex::rotationUnits::deg, 100, vex::velocityUnits::pct, true);
                	Scrapper.setTimeout(750, vex::timeUnits::msec);
                }
                //switch pos cause it moved
                scrapperPos = !scrapperPos;
        		//bool used to control motor hold for scrapper
        		if(scrapperPos){
        			scrapperUp = true;
        		}
        		else if(!scrapperPos){
        			scrapperUp = false;
        		}
        		
        		scrapperEnabled = false;
                }  
    }

/*
     void moveWithShooting(){
    	if(angleTrigger){
    		scrapperEnabled = true;
            if(anglePos == 0){

            	Scrapper.rotateTo(-200, vex::rotationUnits::deg, 100, vex::velocityUnits::pct, true);
            	Scrapper.setTimeout(750, vex::timeUnits::msec);
            	scrapperUp = true;

            }
            //medium flag
            else if(anglePos == 1){
            	Scrapper.rotateTo(-250, vex::rotationUnits::deg, 100, vex::velocityUnits::pct, true);
            	Scrapper.setTimeout(750, vex::timeUnits::msec);
            	scrapperUp = true;
            }
            //lowest flag
            else if(anglePos == 2){
            	Scrapper.rotateTo(-150, vex::rotationUnits::deg, 100, vex::velocityUnits::pct, true);
            	Scrapper.setTimeout(750, vex::timeUnits::msec);
            	scrapperUp = true;

            }
            scrapperEnabled = false;
        }
    }
*/

    void driveTaskFunc(){
        //the functions that run in this "othertask"
        
        //actions
        autoAngle();
       
        //puncher auto button
        angleTriggerDetect();
        
        //drive lock for platform
        driveLockDetect();
    }

void liftTaskFunc(){
        //the functions that run in this "othertask"
        
        //toggle
        scrapperMedium();

        //moveWithShooting();
        
    }

    
int driveTask(){
        while(true){
            driveTaskFunc();
            //to not waste resources
            vex::task::sleep(20);
        }
        return 0;
    }

int liftTask(){
        while(true){
            liftTaskFunc();
            //to not waste resources
            vex::task::sleep(20);
        }
        return 0;
    }

    void controllerDisplay(){
            Controller1.Screen.clearScreen();


                    if(!driveLockOn){
                    Controller1.Screen.setCursor(3, 1);
                    //Controller1.Screen.print("               Off");
                    Controller1.Screen.print("Off");
                    }
                    else
                    {
                        Controller1.Screen.setCursor(3, 1);
                    Controller1.Screen.print("On");
                    }
        
                    Controller1.Screen.setCursor(1,1);
                    if(anglePos == 0){
                        Controller1.Screen.print("High");
                    }
                    else if(anglePos == 1){
                        Controller1.Screen.print("Medium");
                    }
                    else{
                        Controller1.Screen.print("Low");
                    }
                
                     
        }

    void brainDisplay(){
        Brain.Screen.clearScreen();
                //Brain.Screen.printAt(1, 115, "%d", vex::timer::system());

             // Brain.Screen.printAt(1, 120, "%d", test);
              //Brain.Screen.printAt(1, 15, "%d", Gyro.value(vex::analogUnits::pct));
              //Brain.Screen.printAt(1, 15, "%d", Gyro.value(vex::analogUnits::range8bit));
             // Brain.Screen.printAt(1, 55, "%d", Gyro.value(vex::analogUnits::range10bit));
              //Brain.Screen.printAt(1, 35, "%d", Gyro.value(vex::analogUnits::range12bit));
              //Brain.Screen.printAt(1, 55, "%.6f", (gScale * Gyro2.value(vex::analogUnits::range8bit)));

              //Brain.Screen.printAt(1, 55, "%.6f", driveAvg());


             // Brain.Screen.printAt(1, 75, "%.6f", (gScale * Gyro2.value(vex::analogUnits::range12bit)));
             // Brain.Screen.printAt(1, 135, "%.6f", (avgGyro()));  
            //  Brain.Screen.printAt(1, 155, "%.6f", (   (Gyro.value(vex::analogUnits::range12bit) + (gScale * Gyro2.value(vex::analogUnits::range12bit)))  * 0.5  ));
              //Brain.Screen.printAt(1, 115, "%.6f", FrontLeft.rotation(vex::rotationUnits::deg));
              //Brain.Screen.printAt(1, 135, "%.6f", BackLeft.rotation(vex::rotationUnits::deg));
              //Brain.Screen.printAt(1, 155, "%.6f", FrontRight.rotation(vex::rotationUnits::deg));
              //Brain.Screen.printAt(1, 175, "%.6f", BackRight.rotation(vex::rotationUnits::deg));
         
              //Brain.Screen.printAt(1, 195, "5FlagRed");          
    }



    //task only used to update brain and controller displays
    //also used to select auton's
    int displayTask(){
        while(true){
            controllerDisplay();
            brainDisplay();
            //to not waste resources - 150 cause display doesn't need to be updated super fast
            vex::task::sleep(150);
        }
        return 0;
    }

    
    void driveTrainControl(void){
        
        //lock drive if joysticks not moved
      /*  if((abs(Controller1.Axis2.value()) < 15) && (abs(Controller1.Axis3.value()) < 15)) {
            driveLock(true);     
        }
        */
        //else
        //if(driveType){

        //if(liftUp){
            FrontLeft.spin(vex::directionType::fwd, Controller1.Axis3.value() * 1, vex::velocityUnits::pct);
            BackLeft.spin(vex::directionType::fwd, Controller1.Axis3.value() * 1, vex::velocityUnits::pct);
            FrontRight.spin(vex::directionType::fwd, Controller1.Axis2.value() * 1, vex::velocityUnits::pct);
            BackRight.spin(vex::directionType::fwd, Controller1.Axis2.value() * 1, vex::velocityUnits::pct);
       // }
       // else {
          /*  FrontLeft.spin(vex::directionType::fwd, Controller1.Axis3.value() * 1.0, vex::velocityUnits::pct);
            BackLeft.spin(vex::directionType::fwd, Controller1.Axis3.value() * 1.0, vex::velocityUnits::pct);
            FrontRight.spin(vex::directionType::fwd, Controller1.Axis2.value() * 1.0, vex::velocityUnits::pct);
            BackRight.spin(vex::directionType::fwd, Controller1.Axis2.value() * 1.0, vex::velocityUnits::pct);
            */
        //}

    }

    //intake control for roller
    //if drivetype is true, run shooting mode
    void IntakeControl(void){

            if(Controller1.ButtonL2.pressing()){
                Intake.spin(vex::directionType::fwd, (maxSpeed * 1), vex::velocityUnits::pct);
            }
            else if(Controller1.ButtonL1.pressing()){
                Intake.spin(vex::directionType::rev, (maxSpeed * 1), vex::velocityUnits::pct);
            }
            else {
                Intake.stop(vex::brakeType::coast);
            }
        }
    
       
   // void PuncherControl(void){
    //button  

                        /*
                if(Controller1.ButtonR1.pressing()){
                    Puncher.spin(vex::directionType::rev, maxSpeed / 1.5, vex::velocityUnits::pct);
                }
                
                else if(Controller1.ButtonR2.pressing()){
                    liftOn = false;
                    puncherIsMoving = true;
                    Puncher.spin(vex::directionType::fwd, maxSpeed, vex::velocityUnits::pct);

                    //turn lift holding off if shooting
                    if(liftActivate){
                      liftActivate = false;
                    }
                    

                }
                
                else {
                    puncherIsMoving = false;
                    Puncher.stop(vex::brakeType::coast);
                    //Puncher.stop(vex::brakeType::brake);
                }
                
        }
        */
        
    void scrapperControl(void){ 
    	if(!scrapperEnabled){
        if(Controller1.ButtonX.pressing()){
        	//if button is pressed, turn lock off
        	scrapperUp = false;
                Scrapper.spin(vex::directionType::fwd, maxSpeed * 1, vex::velocityUnits::pct);
            }
        else if(Controller1.ButtonB.pressing()){
        	//if button is pressed, turn lock off
        	scrapperUp = false;
                    Scrapper.spin(vex::directionType::rev, maxSpeed * 1, vex::velocityUnits::pct);
            }
            else {
            	if(scrapperUp)
                	Scrapper.stop(vex::brakeType::hold);
                else
                	Scrapper.stop(vex::brakeType::coast);
            }

            }
    }
        
    void allRemoteFunc(void){
        scrapperControl();
        //PuncherControl();
        IntakeControl();
        driveTrainControl();      
    }

void usercontrol( void ) {
    autoRunning = false;
  // User control code here, inside the loop
    
  //initiate task for triggers, like cap control and puncher button
  //vex::task stop(autoTask); 
  vex::task driveTriggers(driveTask);
  vex::task ratchetTriggers(ratchetTask);
  vex::task liftTriggers(liftTask);
  int pLastVal = 0;
  
  //initiate task for brain and controller displays
  vex::task display(displayTask);

        Puncher.stop(vex::brakeType::coast);
        Intake.stop(vex::brakeType::coast);
        Puncher.resetRotation();
        driveCoast();
        resetDrive();
    
  while (true) {
    allRemoteFunc();  

    vex::task::sleep(20); //Sleep the task for a short amount of time to prevent wasted resources. 
  }
}

int main() {

    
    //Run the pre-autonomous function. 
    pre_auton();
    
    //Set up callbacks for autonomous and driver control periods.
    Competition.autonomous(autonomous);
    Competition.drivercontrol(usercontrol);

    //Prevent main from exiting with an infinite loop.                        
    while(true) {
      vex::task::sleep(100);//Sleep the task for a short amount of time to prevent wasted resources.
    }    
       
}   
